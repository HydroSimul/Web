legend.position = "inside",
legend.position.inside = c(0.99, 0.01),
legend.justification = c("right", "bottom"),
legend.direction = "horizontal",
legend.title.position = "top"
) +
guides(
color = guide_colorbar(
barwidth = 8,
barheight = 0.6
)
)
gp_Fit <- ggplot() +
geom_point(data = vario_S50, aes(x = dist, y = gamma, color = dist), size = 3) +
geom_line(data = df_Cuver_Fit, aes(x = dist, y = gamma),
color = color_TUD_orange, linewidth = 1) +
scale_color_gradientn("Distance h (°)",
colors = color_DRESDEN) +
labs(x = "Diistance (°)", y = "Semivariance")  +
theme(
axis.text.y = element_text(angle = 90, hjust = .5),
legend.position = "inside",
legend.position.inside = c(0.99, 0.01),
legend.justification = c("right", "bottom"),
legend.direction = "horizontal",
legend.title.position = "top"
) +
guides(
color = guide_colorbar(
barwidth = 8,
barheight = 0.6
)
)
(gp_Seg | gp_Fit)
#| fig-fullwidth: true
#| fig-width: 10
#| fig-height: 6.5
#| echo: false
# Create general variogram models with typical parameters
model_varioGenaral <- list(
Exponential = vgm(psill = 1, "Exp", range = 1, nugget = 0.1),
Spherical = vgm(psill = 1, "Sph", range = 1, nugget = 0.1),
Circular = vgm(psill = 1, "Cir", range = 1, nugget = 0.1),
Gaussian = vgm(psill = 1, "Gau", range = 1, nugget = 0.1),
Linear = vgm(psill = 1, "Lin", range = 1, nugget = 0.1),
Matern = vgm(psill = 1, "Mat", range = 1, nugget = 0.1, kappa = 1)
)
# Generate curves for all models
df_varioGenaral <- data.frame()
for (model_name in names(model_varioGenaral)) {
df_model <- variogramLine(model_varioGenaral[[model_name]], maxdist = 2, n = 100)
df_model$model <- model_name
df_varioGenaral <- rbind(df_varioGenaral, df_model)
}
# Convert to factor for proper ordering
df_varioGenaral$model <- factor(df_varioGenaral$model,
levels = c("Exponential", "Spherical", "Circular",
"Gaussian", "Linear", "Matern"))
# Plot
ggplot(df_varioGenaral, aes(x = dist, y = gamma)) +
geom_line(color = color_RUB_green, linewidth = 1) +
facet_wrap(~model, ncol = 3, scales = "fixed") +
labs(x = "Distance", y = "Semivariance",
title = "General Variogram Model Shapes") +
theme(
axis.text.y = element_text(angle = 90, hjust = 0.5)
)
#| code-fold: true
ggplot() +
geom_spatvector(data = vct_Station_NRW_S50, aes(fill = NiederschlagJahr),
shape = 24, size = 4) +
geom_spatvector(data = vct_Boundry_NRW, color = color_TUD_pink, fill = NA) +
scale_fill_gradientn("Value",
colors = color_DRESDEN,
na.value = "transparent",
limits = c(550, 1500)) +
ggtitle('Mean Annual Precipitation (1981–2010)') +
coord_sf(expand = FALSE) +
theme(axis.title = element_blank(),
axis.text.y = element_text(angle = 90, hjust = .5))
# Create a template raster over the NRW boundary
# 'rast(vct_Boundry_NRW, res = 0.01)' defines a raster with 0.01 degree resolution
rst_Template_NRW <- rast(vct_Boundry_NRW, res = 0.01)
# Assign a default value of 1 to all raster cells
values(rst_Template_NRW) <- 1
# Mask the raster using the NRW boundary
# This sets all cells outside the boundary to NA
rst_Template_NRW <- mask(rst_Template_NRW, vct_Boundry_NRW)
# Convert station SpatVector to a data frame including coordinates
# 'geom(...)[, c("x", "y")]' extracts x and y coordinates
# 'as.data.frame(...)' extracts attribute data
df_Station_NRW_S50 <- data.frame(
geom(vct_Station_NRW_S50)[, c("x", "y")],
as.data.frame(vct_Station_NRW_S50)
)
# Create a gstat model for nearest neighbor interpolation
# 'NiederschlagJahr ~ 1' models only the mean (no trend)
# 'locations = ~x + y' specifies station coordinates
# 'nmax = 1' uses only the nearest station for each prediction
# 'set = list(idp = 0)' sets inverse distance power to 0, making it pure nearest neighbor
model_Near1 <- gstat(
formula = NiederschlagJahr ~ 1,
locations = ~x + y,
data = df_Station_NRW_S50,
nmax = 1,
set = list(idp = 0)
)
# Interpolate the raster using the nearest neighbor model
# 'rst_Template_NRW' provides the grid where predictions are made
# 'mask(vct_Boundry_NRW)' ensures values outside NRW are set to NA
rst_Near1 <- interpolate(rst_Template_NRW, model_Near1, debug.level = 0) |>
mask(vct_Boundry_NRW)
# Create Voronoi polygons from the station locations
# Each Voronoi cell contains all points closer to that station than to any other
vct_Voronoi_NRW_S50 <- voronoi(vct_Station_NRW_S50) |>
# Crop the Voronoi polygons to the NRW boundary
# Ensures polygons do not extend beyond the study area
crop(vct_Boundry_NRW)
#| fig-fullwidth: true
#| fig-width: 12
#| fig-height: 6.5
#| code-fold: true
gp_Near1 <- ggplot() +
geom_spatraster(data = rst_Near1, aes(fill = var1.pred)) +
geom_spatvector(data = vct_Boundry_NRW, color = color_TUD_pink, fill = NA) +
scale_fill_gradientn("Value",
colors = color_DRESDEN,
na.value = "transparent",
limits = c(550, 1500)) +
ggtitle('Nearest Neighbor (1-nearest)') +
coord_sf(expand = FALSE) +
theme(axis.title = element_blank(),
axis.text.y = element_text(angle = 90, hjust = .5),
legend.position = "inside",
legend.position.inside = c(0.99, 0.01),
legend.justification = c("right", "bottom"),
legend.direction = "horizontal",
legend.title.position = "top"
) +
guides(
fill = guide_colorbar(
barwidth = 8,
barheight = 0.6
)
)
gp_Voronoi_NRW_S50 <- ggplot() +
geom_spatvector(data = vct_Voronoi_NRW_S50, aes(fill = NiederschlagJahr)) +
geom_spatvector(data = vct_Boundry_NRW, color = color_TUD_pink, fill = NA) +
scale_fill_gradientn("Value",
colors = color_DRESDEN,
na.value = "transparent",
limits = c(550, 1500)) +
ggtitle('Thiessen Polygons') +
coord_sf(expand = FALSE) +
theme(axis.title = element_blank(),
axis.text.y = element_text(angle = 90, hjust = .5),
legend.position = "inside",
legend.position.inside = c(0.99, 0.01),
legend.justification = c("right", "bottom"),
legend.direction = "horizontal",
legend.title.position = "top"
) +
guides(
fill = guide_colorbar(
barwidth = 8,
barheight = 0.6
)
)
(gp_Near1 | gp_Voronoi_NRW_S50)
# Create a gstat model for nearest neighbor interpolation using the 5 closest stations
# 'NiederschlagJahr ~ 1' models only the mean (no trend)
# 'locations = ~x + y' specifies station coordinates
# 'nmax = 5' uses the 5 nearest stations for each prediction
# 'set = list(idp = 0)' sets inverse distance power to 0, so all selected stations are equally weighted
model_Near5 <- gstat(
formula = NiederschlagJahr ~ 1,
locations = ~x + y,
data = df_Station_NRW_S50,
nmax = 5,
set = list(idp = 0)
)
# Interpolate the raster using the nearest 5 neighbor model
# 'rst_Template_NRW' provides the grid for predictions
# 'mask(vct_Boundry_NRW)' ensures values outside NRW are set to NA
rst_Near5 <- interpolate(rst_Template_NRW, model_Near5, debug.level = 0) |>
mask(vct_Boundry_NRW)
#| fig-fullwidth: true
#| fig-width: 12
#| fig-height: 6.5
#| code-fold: true
gp_Near5 <- ggplot() +
geom_spatraster(data = rst_Near5, aes(fill = var1.pred)) +
geom_spatvector(data = vct_Boundry_NRW, color = color_TUD_pink, fill = NA) +
geom_spatvector(data = vct_Station_NRW_S50, aes(fill = NiederschlagJahr),
shape = 24, size = 3, color = "grey96", linewidth = 1) +
scale_fill_gradientn("Value",
colors = color_DRESDEN,
na.value = "transparent",
limits = c(550, 1500)) +
ggtitle('k-Nearest Neighbors') +
coord_sf(expand = FALSE) +
theme(axis.title = element_blank(),
axis.text.y = element_text(angle = 90, hjust = .5),
legend.position = "inside",
legend.position.inside = c(0.99, 0.01),
legend.justification = c("right", "bottom"),
legend.direction = "horizontal",
legend.title.position = "top"
) +
guides(
fill = guide_colorbar(
barwidth = 8,
barheight = 0.6
)
)
(gp_Near1 | gp_Near5)
# Create a gstat model for inverse distance weighted (IDW) interpolation
# 'NiederschlagJahr ~ 1' models only the mean (no trend)
# 'locations = ~x + y' specifies station coordinates
# 'nmax = 5' uses the 5 nearest stations for each prediction
# Since 'idp' is not set, the default inverse distance weighting is applied
model_IDW <- gstat(
formula = NiederschlagJahr ~ 1,
locations = ~x + y,
data = df_Station_NRW_S50,
nmax = 5
)
# Interpolate the raster using the IDW model
# 'rst_Template_NRW' provides the grid for predictions
# 'mask(vct_Boundry_NRW)' ensures values outside NRW are set to NA
rst_IDW <- interpolate(rst_Template_NRW, model_IDW, debug.level = 0) |>
mask(vct_Boundry_NRW)
#| fig-fullwidth: true
#| fig-width: 12
#| fig-height: 6.5
#| code-fold: true
gp_IDW <- ggplot() +
geom_spatraster(data = rst_IDW, aes(fill = var1.pred)) +
geom_spatvector(data = vct_Boundry_NRW, color = color_TUD_pink, fill = NA) +
scale_fill_gradientn("Value",
colors = color_DRESDEN,
na.value = "transparent",
limits = c(550, 1500)) +
ggtitle('Inverse Distance Weighting (IDW)') +
coord_sf(expand = FALSE) +
theme(axis.title = element_blank(),
axis.text.y = element_text(angle = 90, hjust = .5),
legend.position = "inside",
legend.position.inside = c(0.99, 0.01),
legend.justification = c("right", "bottom"),
legend.direction = "horizontal",
legend.title.position = "top"
) +
guides(
fill = guide_colorbar(
barwidth = 8,
barheight = 0.6
)
)
(gp_Near5 | gp_IDW)
# Define combinations of neighbors (nmax) and inverse distance powers (idp) for IDW
# Each element is a list with a specific nmax and idp value
lst_IDW_Params <- list(
k5p1  = list(nmax = 5, idp = 1),   # 5 nearest neighbors, idp = 1
k10p1 = list(nmax = 10, idp = 1),  # 10 nearest neighbors, idp = 1
k5p3  = list(nmax = 5, idp = 3),   # 5 nearest neighbors, idp = 3 (stronger weighting for closer stations)
k10p3 = list(nmax = 10, idp = 3)   # 10 nearest neighbors, idp = 3
)
# Function to create an IDW raster given nmax and idp
create_idw <- function(nmax, idp) {
# Set up gstat model for IDW
model <- gstat(
formula = NiederschlagJahr ~ 1,       # model only the mean
locations = ~x + y,                    # use station coordinates
data = df_Station_NRW_S50,            # station data
nmax = nmax,                           # number of nearest neighbors
set = list(idp = idp)                  # inverse distance power
)
# Interpolate on the template raster and mask to NRW boundary
interpolate(rst_Template_NRW, model, debug.level = 0) |>
mask(vct_Boundry_NRW)
}
# Generate IDW rasters for all parameter combinations
# Result is a list of raster layers, one for each combination
lst_rst_IDW <- lapply(lst_IDW_Params, \(p) create_idw(p$nmax, p$idp))
#| code-fold: true
#| fig-fullwidth: true
#| fig-width: 12
#| fig-height: 13
rst_IDW_combined <- rast(lst_rst_IDW)
rst_IDW_combined <- rst_IDW_combined[[c(1, 3, 5, 7)]]
# Set layer names to match parameter combinations
names(rst_IDW_combined) <- c("k=5, p=1", "k=10, p=1", "k=5, p=3", "k=10, p=3")
# Create facet plot
ggplot() +
geom_spatraster(data = rst_IDW_combined) +
geom_spatvector(data = vct_Boundry_NRW, color = color_TUD_pink, fill = NA) +
facet_wrap(~lyr, ncol = 2) +
scale_fill_gradientn("Value",
colors = color_DRESDEN,
na.value = "transparent",
limits = c(550, 1500)) +
coord_sf(expand = FALSE) +
labs(title = "Inverse Distance Weighting (IDW) - Parameter Comparison") +
theme(
axis.title = element_blank(),
axis.text.y = element_text(angle = 90, hjust = 0.5),
legend.position = "inside",
legend.position.inside = c(0.99, 0.01),
legend.justification = c("right", "bottom"),
legend.direction = "horizontal",
legend.title.position = "top",
strip.text = element_text(size = 10, face = "bold")
) +
guides(
fill = guide_colorbar(
barwidth = 8,
barheight = 0.6
)
)
# Set up a gstat model for variogram calculation
# 'NiederschlagJahr ~ 1' models only the mean (no trend)
# 'locations = ~x + y' specifies the station coordinates
model_Vario <- gstat(
formula = NiederschlagJahr ~ 1,
locations = ~x + y,
data = df_Station_NRW_S50
)
# Compute the experimental variogram with a lag width of 0.05
vario_S50 <- variogram(model_Vario, width = 0.05)
# Define names of theoretical variogram models to try
name_VarioModel <- c("Exp", "Sph", "Cir", "Gau", "Lin", "Mat")
names(name_VarioModel) <- name_VarioModel  # set names for easier reference
# Set initial parameters for variogram fitting
num_psill  <- 6e4    # partial sill (variance explained by spatial structure)
num_range  <- 0.5    # range (distance beyond which points are uncorrelated)
num_nugget <- 3e3    # nugget effect (small-scale variability or measurement error)
# Fit variogram models (excluding 'Mat') to the experimental variogram
lst_FitVario <- map(name_VarioModel[-6], \(m_Vario)
fit.variogram(vario_S50, vgm(num_psill, m_Vario, num_range, num_nugget))
)
# Fit the 'Matérn' variogram separately with kappa = 0.9
lst_FitVario$Mat <- fit.variogram(
vario_S50,
vgm(num_psill, "Mat", num_range, num_nugget, kappa = 0.9)
)
#| fig-fullwidth: true
#| fig-width: 12
#| fig-height: 6.5
#| code-fold: true
lst_df_VarioLine <- map(lst_FitVario, variogramLine, maxdist = max(vario_S50$dist))
df_VarioLine_All <- do.call(rbind, lst_df_VarioLine)
df_VarioLine_All$model <- rep(c("Exponential", "Spherical", "Circular", "Gaussian", "Linear", "Matern"), each = 200)
# Create color palette for models
model_colors <- c(
"Exponential" = color_TUD_orange,
"Spherical" = color_RUB_blue,
"Circular" = color_TUD_lightblue,
"Gaussian" = color_RUB_green,
"Linear" = color_TUD_pink,
"Matern" = color_TUD_redpurple
)
# Determine the y-axis range from your data
y_range <- range(vario_S50$gamma, df_VarioLine_All$gamma, na.rm = TRUE)
gp_Fit <- ggplot() +
geom_point(data = vario_S50, aes(x = dist, y = gamma), size = 3, shape = 1, color = color_RUB_blue) +
geom_line(data = df_VarioLine_All, aes(x = dist, y = gamma, color = model), linewidth = 1) +
scale_color_manual("Model", values = model_colors) +
labs(x = "Distance (°)", y = NULL) +  # Remove y-axis title
lims(y = y_range) +  # Same y-axis range
theme(
axis.text.y = element_blank(),  # Remove y-axis text
axis.ticks.y = element_blank(), # Remove y-axis ticks
legend.position = "inside",
legend.justification = c("right", "bottom"),
legend.position.inside = c(0.99, 0.01)
)
gp_Scatter <- ggplot() +
geom_point(data = vario_S50, aes(x = dist, y = gamma, color = dist), size = 3) +
scale_color_gradientn("Distance h (°)", colors = color_DRESDEN) +
labs(x = "Distance (°)", y = "Semivariance") +
lims(y = y_range) +
theme(
axis.text.y = element_text(angle = 90, hjust = .5),
legend.position = "inside",
legend.position.inside = c(0.99, 0.01),
legend.justification = c("right", "bottom"),
legend.direction = "horizontal",
legend.title.position = "top"
) +
guides(
color = guide_colorbar(barwidth = 8, barheight = 0.6)
)
# Combine the plots
(gp_Scatter | gp_Fit) +
plot_annotation(title = "Variogram Models Comparison")
# Compute RMSE for each fitted variogram model using cross-validation
lst_RMSE_VarioFit <- map(lst_FitVario, \(m_Fit) {
# Perform leave-one-out cross-validation using kriging
# 'NiederschlagJahr ~ 1' models only the mean
# 'locations = ~x + y' specifies station coordinates
# 'model = m_Fit' uses the fitted variogram model
cv_model <- krige.cv(
NiederschlagJahr ~ 1,
locations = ~x + y,
data = df_Station,
model = m_Fit
)
# Extract observed and predicted values
obs  <- cv_model$observed
pred <- cv_model$var1.pred
# Compute Root Mean Squared Error (RMSE)
# 'na.rm = TRUE' ignores missing values
sqrt(mean((obs - pred)^2, na.rm = TRUE))
})
# Print the RMSE values for all variogram models
print(lst_RMSE_VarioFit |> unlist())
# Create an ordinary kriging (OK) model using the spherical variogram
# 'NiederschlagJahr ~ 1' models only the mean (no trend)
# 'locations = ~x + y' specifies the station coordinates
# 'model = lst_FitVario$Sph' uses the fitted spherical variogram
# 'nmax = 5' limits the number of nearest stations used for each prediction
model_OK <- gstat(
formula = NiederschlagJahr ~ 1,
locations = ~x + y,
data = df_Station,
model = lst_FitVario$Sph,
nmax = 5
)
# Interpolate precipitation values on the raster grid using ordinary kriging
# 'rst_Template_NRW' provides the grid for prediction
# 'mask(vct_Boundry_NRW)' ensures results are limited to NRW boundary
rst_OK <- interpolate(rst_Template_NRW, model_OK, debug.level = 0) |>
mask(vct_Boundry_NRW)
#| fig-fullwidth: true
#| fig-width: 12
#| fig-height: 6.5
#| code-fold: true
gp_OK <- ggplot() +
geom_spatraster(data = rst_OK, aes(fill = var1.pred)) +
geom_spatvector(data = vct_Boundry_NRW, color = color_TUD_pink, fill = NA) +
geom_spatvector(data = vct_Station_NRW_S50, aes(fill = NiederschlagJahr),
shape = 24, size = 3, color = "grey96", linewidth = 1) +
scale_fill_gradientn("Value",
colors = color_DRESDEN,
na.value = "transparent",
limits = c(550, 1500)) +
ggtitle('Ordinary Kriging with Spherical Variogramm') +
coord_sf(expand = FALSE) +
theme(axis.title = element_blank(),
axis.text.y = element_text(angle = 90, hjust = .5),
legend.position = "inside",
legend.position.inside = c(0.99, 0.01),
legend.justification = c("right", "bottom"),
legend.direction = "horizontal",
legend.title.position = "top"
) +
guides(
fill = guide_colorbar(
barwidth = 8,
barheight = 0.6
)
)
(gp_IDW | gp_OK)
# Generate ordinary kriging rasters for all fitted variogram models
lst_rst_OK_VarioModel <- map(lst_FitVario, \(m_OK) {
# Create ordinary kriging model using the fitted variogram
model_OK <- gstat(
formula = NiederschlagJahr ~ 1,   # model only the mean
locations = ~x + y,                # use station coordinates
data = df_Station,                 # station data
model = m_OK                        # use the current variogram model from the list
)
# Interpolate the raster using the kriging model and mask to NRW boundary
interpolate(rst_Template_NRW, model_OK, debug.level = 0) |>
mask(vct_Boundry_NRW)
})
#| code-fold: true
#| fig-fullwidth: true
#| fig-width: 12
#| fig-height: 13
rst_OK_combined <- rast(lst_rst_OK_VarioModel)
rst_OK_combined <- rst_OK_combined[[c(1, 3, 5, 7, 9, 11)]]
# Set layer names to match parameter combinations
names(rst_OK_combined) <- names(lst_rst_OK_VarioModel)
# Create facet plot
ggplot() +
geom_spatraster(data = rst_OK_combined[[1:4]]) +
geom_spatvector(data = vct_Boundry_NRW, color = color_TUD_pink, fill = NA) +
facet_wrap(~lyr, ncol = 2) +
scale_fill_gradientn("Value",
colors = color_DRESDEN,
na.value = "transparent",
limits = c(550, 1500)) +
coord_sf(expand = FALSE) +
labs(title = "Ordinary Kriging (OK) - Variogram Comparison") +
theme(
axis.title = element_blank(),
axis.text.y = element_text(angle = 90, hjust = 0.5),
legend.position = "inside",
legend.position.inside = c(0.99, 0.01),
legend.justification = c("right", "bottom"),
legend.direction = "horizontal",
legend.title.position = "top",
strip.text = element_text(size = 10, face = "bold")
) +
guides(
fill = guide_colorbar(
barwidth = 8,
barheight = 0.6
)
)
