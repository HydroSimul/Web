{
  "hash": "f1b1d1c6263542be6240b34814c8446e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R & Python Basic\"\nnumber-sections: true\n---\n\n\n\n\nMore Details of R in [R for Data Science (2e)](https://r4ds.hadley.nz/index.html) and [Advanced R](https://adv-r.hadley.nz/index.html)\n\nMore Details of Python in [Automate the Boring Stuff with Python](https://automatetheboringstuff.com/) and [W3 School Python](https://www.w3schools.com/python/default.asp)\n\nThis article serves as a **brief introduction** to the fundamental coding aspects of both R and Python. \nIt provides a first impression of these scripting languages. For a more comprehensive understanding and in-depth techniques related to both languages, you are encouraged to explore the website mentioned above. The content here is primarily a condensed compilation of information from the provided links, aimed at facilitating a comparison between R and Python.\n\n\n**Data** and **Functions** are the two essential components of every programming language, especially in the context of data science and data processing. They can be likened to nouns and verbs in natural languages. **Data** describes information, while **Functions** define actions for manipulating that data.\n\nThis article is divided into two main sections: **Data** (@sec-data) and **Coding** (@sec-coding).\n\n\nIn the Data section, we will explore:\n\n1. Basic **datatypes & structures**, such as datatypes with numbers, characters, and booleans, data structures with list or data frame.\n2. Fundamentals of **CRUD (Create, Read, Update, Delete)** operations.\n\n\nIn the Coding section, we will delve into three key aspects:\n\n1. Fundamental **mathematics**.\n2. Control flow, including decision-making (**choices**) and **looping**.\n3. Creating and invoking **functions**.\n\nThe above five elements can be considered as the most fundamental elements of every scripting language. Additionally, we will explore **object creation and naming** in a section called 'New Objects' (@sec-naming). Objects can encompass functions and variables, further enriching our understanding of scripting.\n\nThis article will provide a solid introduction to the core concepts in programming, laying the groundwork for further exploration in both R and Python.\n\nOverview:\n\n![](../images/basic_data.svg)\n![](../images/basic_coding.svg)\n\n# Data {#sec-data}\n\nIn the data section, we will explore various aspects of data, including:\n\n- Understanding basic **data types and structures**: We'll delve into how data is stored and organized, laying the foundation for data manipulation.\n\n- Mastering **indexing and subsetting**: We'll investigate indexing methods across different programming languages and learn how to extract subsets from various data structures.\n\n- Navigating **CRUD** operations: We'll cover the fundamentals of **CRUD (Create, Read, Update, Delete)** operations, essential for data manipulation and management, among other topics.\n\n\n\n\n## Datatypes & Structure\n\nIn programming, the concept of datatypes is fundamental. It forms the basis for how we handle and manipulate information in software.\nThe most basic data types, such as **integers**, **numerics**, **booleans**, **characters**, and **bytes**, are supported by almost all programming languages. \nAdditionally, there are more complex data types built upon these basics, like **strings**, which are sequences of characters, and dates, which can be represented as variables of integers and more.\n\nData structures are equally important, as they determine the organization of data, whether it involves the same data types in **multiple dimensions** or **combinations of different types**. \nData types and structures are intertwined, serving as the cornerstone for our programming endeavors.\n\nVariables play a pivotal role in storing data of different types. \nThe choice of data type and structure is critical, as different types and structures enable various operations and functionalities. \nTherefore, understanding data types and structures is paramount before embarking on data manipulation tasks.\n\n### Datatypes\n\nA data type of a variable specifies the type of data that is stored inside that variable. In this context, we will just discuss **Atomic Variables**, which represent fundamental data types. There are six basic atomic data types:\n\n1. **Logical** (boolean data type)\n    - can only have two values: `TRUE` and `FALSE`\n2. **Numeric** (double, float, lang)\n    - represents all real numbers with or without decimal values.\n3. **Integer** \n    - specifies real values without decimal points.\n4. **Complex** \n    - is used to specify purely imaginary values\n5. **Character** (string)\n    - data type is used to specify character or string values in a variable\n6. **Raw** (bytes)\n    - specifies values as raw bytes\n\n\n::: {.panel-tabset}\n\n## R\n\nIn R, variables do not require explicit declaration with a particular data type. Instead, R is dynamically typed, allowing variables to adapt to the data they contain. You can use the following techniques to work with data types in R:\n\n- **Checking Data Types:** To determine the data type of a variable, you can use the `class()` function. \n\n- **Type Conversion:** When needed, you can change the data type of a variable using R's conversion functions, typically prefixed with `as.`. \n\nR's flexibility in data type handling simplifies programming tasks and allows for efficient data manipulation without the need for explicit type declarations.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Numeric\nx <- 10.5\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Integer\nx <- 1000L\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Complex\nx <- 9i + 3\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"complex\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Character/String\nx <- \"R is exciting\"\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Logical/Boolean\nx <- TRUE\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Convert\ny <- as.numeric(x)\nclass(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Raw (bytes)\nx <- charToRaw(\"A\")\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 41\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"raw\"\n```\n\n\n:::\n:::\n\n\n\n\n## Python\n\nIn Python, variables also do not require explicit declaration with a particular data type. Python is dynamically typed, allowing variables to adapt to the data they contain. You can use the following techniques to work with data types in Python:\n\n- **Checking Data Types:** To determine the data type of a variable, you can use the `type()` function. It allows you to inspect the current data type of a variable.\n\n- **Type Conversion:** When needed, you can change the data type of a variable in Python using various conversion functions, like `float()`. \n\nPython's flexibility in data type handling simplifies programming tasks and allows for efficient data manipulation without the need for explicit type declarations.\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Numeric\nx = 10.5\nprint(type(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'float'>\n```\n\n\n:::\n\n```{.python .cell-code}\n# Integer\nx = 1000\nprint(type(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'int'>\n```\n\n\n:::\n\n```{.python .cell-code}\n# Complex\nx = 9j + 3\nprint(type(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'complex'>\n```\n\n\n:::\n\n```{.python .cell-code}\n# Character/String\nx = \"Python is exciting\"\nprint(type(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'str'>\n```\n\n\n:::\n\n```{.python .cell-code}\n# Logical/Boolean\nx = True\nprint(type(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'bool'>\n```\n\n\n:::\n\n```{.python .cell-code}\n# Convert to Numeric\ny = float(x)\nprint(type(y))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'float'>\n```\n\n\n:::\n\n```{.python .cell-code}\n# Raw (bytes)\nx = b'A'\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nb'A'\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(type(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'bytes'>\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n\n### Data Structure\n\nComparatively, data structures between R and Python tend to exhibit more differences than their data types. However, by incorporating additional libraries like NumPy and pandas, we can access shared data structures which play a vital role in the field of data science.\n\n1. **Vector:** A set of multiple values (items)\n   - Contains items of the same data type or structure\n   - Indexed: Allows you to get and change items using indices\n   - Allows duplicates\n   - Changeable: You can modify, add, and remove items after creation\n\n2. **Array:** A multi-dimensional extension of a vector\n    - **Matrix**: two dimensions\n\n3. **List:** A set of multiple values (items)\n   - Contains items of different data types or structures\n   - Indexed: Allows you to get and change items using indices\n   - Allows duplicates\n   - Changeable: You can modify, add, and remove items after creation\n\n4. **Table (Data Frame):** Tabular data structure\n   - Two-dimensional objects with rows and columns\n   - Contains elements of several types\n   - Each column has the same data type\n\n::: {.panel-tabset}\n\n## R\n\nThe structure of R variable can be checked with `str()`ucture:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a vector\nvct_Test <- c(1,5,7)\n# View the structure\nstr(vct_Test)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n num [1:3] 1 5 7\n```\n\n\n:::\n\n```{.r .cell-code}\n# Create a array\nary_Test <- array(1:24, c(2,3,4))\n# View the structure\nstr(ary_Test)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n int [1:2, 1:3, 1:4] 1 2 3 4 5 6 7 8 9 10 ...\n```\n\n\n:::\n\n```{.r .cell-code}\n# Create a matrix\nmat_Test <- matrix(1:24, 6, 4)\nmat_Test\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    7   13   19\n[2,]    2    8   14   20\n[3,]    3    9   15   21\n[4,]    4   10   16   22\n[5,]    5   11   17   23\n[6,]    6   12   18   24\n```\n\n\n:::\n\n```{.r .cell-code}\n# View the structure\nstr(mat_Test)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n int [1:6, 1:4] 1 2 3 4 5 6 7 8 9 10 ...\n```\n\n\n:::\n\n```{.r .cell-code}\n# Create a list\nlst_Test <- list(c(1,3,5), \"abc\", FALSE)\n# View the structure\nstr(lst_Test)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 3\n $ : num [1:3] 1 3 5\n $ : chr \"abc\"\n $ : logi FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# Create a table (data frame)\ndf_Test <- data.frame(name = c(\"Bob\", \"Tom\"), age = c(12, 13))\ndf_Test\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  name age\n1  Bob  12\n2  Tom  13\n```\n\n\n:::\n\n```{.r .cell-code}\n# View the structure\nstr(df_Test)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t2 obs. of  2 variables:\n $ name: chr  \"Bob\" \"Tom\"\n $ age : num  12 13\n```\n\n\n:::\n:::\n\n\n\n\n## Python\n\nIn Python, the structure of a variable is treated as the data type, and you can confirm it using the `type()` function.\n\nIt's important to note that some of the most commonly used data structures, such as arrays and data frames (tables), are not part of the core Python language itself. Instead, they are provided by two popular libraries: `numpy` and `pandas`.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\nimport pandas as pd\n\n# Create a vector (list in Python)\nvct_Test = [1, 5, 7]\n# View the structure\nprint(type(vct_Test))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'list'>\n```\n\n\n:::\n\n```{.python .cell-code}\n# Create a 3D array (NumPy ndarray)\nary_Test = np.arange(1, 25).reshape((2, 3, 4))\n# View the structure\nprint(type(ary_Test))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'numpy.ndarray'>\n```\n\n\n:::\n\n```{.python .cell-code}\n# Create a matrix (NumPy ndarray)\nmat_Test = np.arange(1, 25).reshape((6, 4))\nprint(type(mat_Test))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'numpy.ndarray'>\n```\n\n\n:::\n\n```{.python .cell-code}\n# Create a list\nlst_Test = [[1, 3, 5], \"abc\", False]\n# View the structure\nprint(type(lst_Test))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'list'>\n```\n\n\n:::\n\n```{.python .cell-code}\n# Create a table (pandas DataFrame)\ndf_Test = pd.DataFrame({\"name\": [\"Bob\", \"Tom\"], \"age\": [12, 13]})\nprint(type(df_Test))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'pandas.core.frame.DataFrame'>\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(df_Test)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  name  age\n0  Bob   12\n1  Tom   13\n```\n\n\n:::\n:::\n\n\n\n\nPython offers several original data structures, including:\n\n1. **Tuples:** Tuples are ordered collections of elements, similar to lists, but unlike lists, they are immutable, meaning their elements cannot be changed after creation. Tuples are often used to represent fixed collections of items.\n\n2. **Sets:** Sets are unordered collections of unique elements. They are valuable for operations that require uniqueness, such as finding unique values in a dataset or performing set-based operations like unions and intersections.\n\n3. **Dictionaries:** Dictionaries, also known as dicts, are collections of key-value pairs. They are used to store data in a structured and efficient manner, allowing quick access to values using their associated keys.\n\nWhile these data structures may not be as commonly used in data manipulation and calculations as arrays and data frames, they have unique features and use cases that can be valuable in various programming scenarios.\n\n:::\n\n\n## Index & subset\n\nAdditionally, **subsetting** plays a crucial role in data manipulation. Subsetting allows you to extract specific subsets of data based on conditions, criteria, or filters. \n\n\n::: {.panel-tabset}\n\n## R\n\n\n\nMore Details in [Advanced R: 4 Subsetting](https://adv-r.hadley.nz/subsetting.html).\n\nR's subsetting operators are fast and powerful. Mastering them allows you to succinctly perform complex operations in a way that few other languages can match. Subsetting in R is easy to learn but hard to master because you need to internalise a number of interrelated concepts:\n\n* There are six ways to subset atomic vectors.\n\n* There are three subsetting operators, `[[`, `[`, and `$`.\n\n* Subsetting operators interact differently with different vector \n  types (e.g., atomic vectors, lists, factors, matrices, and data frames).\n\nSubsetting is a natural complement to `str()`. While `str()` shows you all the pieces of any object (its structure).\n\n## Python\n\n::: {.callout-tip}\n\nIn Python, indexing starts from 0, not 1.\n\n:::\n\n:::\n\n\n### Vector\n\n::: {.panel-tabset}\n\n## R\n\n\n*   __Positive integers__ return elements at the specified positions: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(2.1, 4.2, 3.3, 5.4)\n\n# One value\nx[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.1\n```\n\n\n:::\n\n```{.r .cell-code}\n# More values\nx[c(1:2, 4)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.1 4.2 5.4\n```\n\n\n:::\n\n```{.r .cell-code}\n# Duplicate indices will duplicate values\nx[c(1, 1)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.1 2.1\n```\n\n\n:::\n\n```{.r .cell-code}\n# Real numbers are silently truncated to integers\nx[c(2.1, 2.9)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.2 4.2\n```\n\n\n:::\n:::\n\n\n\n\n*   __Negative integers__ exclude elements at the specified positions:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Exclude elements\nx[-c(3, 1)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.2 5.4\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-important}\n\n## NOTE \n\nNote that you can't mix positive and negative integers in a single subset:\n\n:::\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[c(-1, 2)]\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in x[c(-1, 2)]: nur Nullen dÃ¼rfen mit negativen Indizes gemischt werden\n```\n\n\n:::\n:::\n\n\n\n\n\n## Python\n\n\n\n*   __Positive integers__ return elements at the specified positions: \n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\nimport pandas as pd\n\n# Create a NumPy array\nx = np.array([2.1, 4.2, 3.3, 5.4])\n\n# One value\nprint(x[0])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n2.1\n```\n\n\n:::\n\n```{.python .cell-code}\n# More values\nprint(x[np.array([0, 1, 3])])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[2.1 4.2 5.4]\n```\n\n\n:::\n\n```{.python .cell-code}\n# Duplicate indices will duplicate values\nprint(x[np.array([0, 0])])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[2.1 2.1]\n```\n\n\n:::\n:::\n\n\n\n* __egative indexing__ to access an array from the end:\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# One value\nprint(x[-1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n5.4\n```\n\n\n:::\n\n```{.python .cell-code}\n# More values\nprint(x[-np.array([1, 3])])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[5.4 4.2]\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n\n\n### Matrices and arrays \n\n::: {.panel-tabset}\n\n## R\n\nThe most common way of subsetting matrices (2D) and arrays (>2D) is a simple generalisation of 1D subsetting: supply a 1D index for each dimension, separated by a comma. Blank subsetting is now useful because it lets you keep all rows or all columns.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a matrix\na2 <- matrix(1:9, nrow = 3)\n# Rename the columns (equivalent to colnames in R)\ncolnames(a2) <- c(\"A\", \"B\", \"C\")\n# Access a specific element using column name\na2[1, \"A\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nA \n1 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Select specific rows with all columns\na2[1:2, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     A B C\n[1,] 1 4 7\n[2,] 2 5 8\n```\n\n\n:::\n\n```{.r .cell-code}\n# columns which are excluded \na2[0, -2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     A C\n```\n\n\n:::\n\n```{.r .cell-code}\n# Create a 3D array\na3 <- array(1:24, c(2,3,4))\n# Access a specific element(s), in different dimensions\na3[1,2,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 9\n```\n\n\n:::\n\n```{.r .cell-code}\na3[1,2,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  3  9 15 21\n```\n\n\n:::\n\n```{.r .cell-code}\na3[1,,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    7   13   19\n[2,]    3    9   15   21\n[3,]    5   11   17   23\n```\n\n\n:::\n:::\n\n\n\n\n## Python\n\nIn Python, the `:` symbol is used to indicate all elements of a particular dimension or slice. It allows you to select or reference all items along that dimension in a sequence, array, or data structure.\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n\n# Create a NumPy matrix\na2 = np.array([[1, 2, 3],\n               [4, 5, 6],\n               [7, 8, 9]])\n\n# Rename the columns (equivalent to colnames in R)\ncolnames = [\"A\", \"B\", \"C\"]\n\n# Access a specific element using column name\nprint(a2[0, colnames.index(\"A\")])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1\n```\n\n\n:::\n\n```{.python .cell-code}\n# Select the first two rows\nprint(a2[0:2, :])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1 2 3]\n [4 5 6]]\n```\n\n\n:::\n\n```{.python .cell-code}\n# Create a NumPy 3D array\na3 = np.arange(1, 25).reshape((2, 3, 4))\n\n# Access a specific element in the 3D array\nprint(a3[0, 1, 1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n6\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(a3[0, 1, :])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[5 6 7 8]\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(a3[0, :, :])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[ 1  2  3  4]\n [ 5  6  7  8]\n [ 9 10 11 12]]\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n\n### Data frames\n\n::: {.panel-tabset}\n\n## R\n\nData frames have the characteristics of both lists and matrices: \n\n* When subsetting with a single index, they behave like lists and index \n  the columns, so `df[1:2]` selects the first two columns.\n  \n* When subsetting with two indices, they behave like matrices, so\n  `df[1:3, ]` selects the first three _rows_ (and all the columns)[^python-dims].\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a DataFrame\ndf <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\n\n# Select rows\ndf[df$x == 2, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y z\n2 2 2 b\n```\n\n\n:::\n\n```{.r .cell-code}\ndf[c(1, 3), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y z\n1 1 3 a\n3 3 1 c\n```\n\n\n:::\n\n```{.r .cell-code}\n# There are two ways to select columns from a data frame\n# Like a list\ndf[c(\"x\", \"z\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x z\n1 1 a\n2 2 b\n3 3 c\n```\n\n\n:::\n\n```{.r .cell-code}\n# Like a matrix\ndf[, c(\"x\", \"z\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x z\n1 1 a\n2 2 b\n3 3 c\n```\n\n\n:::\n\n```{.r .cell-code}\n# There's an important difference if you select a single \n# column: matrix subsetting simplifies by default, list \n# subsetting does not.\nstr(df[\"x\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t3 obs. of  1 variable:\n $ x: int  1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(df[, \"x\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n int [1:3] 1 2 3\n```\n\n\n:::\n:::\n\n\n\n\n## Python\n\nMore detail about Function `pandas.Seies.iloc()` and `pandas.Seies.loc()` in [pandas document](https://pandas.pydata.org/docs/reference/api/pandas.Series.iloc.html)\n\n- `loc` gets rows (and/or columns) with particular **labels**.\n\n- `iloc` gets rows (and/or columns) at **integer** locations.\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\n\n# Create a DataFrame\ndf = pd.DataFrame({'x': range(1, 4), 'y': range(3, 0, -1), 'z': list('abc')})\n\n# Select rows\nprint(df[df['x'] == 2])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   x  y  z\n1  2  2  b\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(df.iloc[[0, 2]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   x  y  z\n0  1  3  a\n2  3  1  c\n```\n\n\n:::\n\n```{.python .cell-code}\n# Select columns\nprint(df[['x', 'z']])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   x  z\n0  1  a\n1  2  b\n2  3  c\n```\n\n\n:::\n\n```{.python .cell-code}\n# Select columns like a DataFrame\nprint(df.loc[:, ['x', 'z']])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   x  z\n0  1  a\n1  2  b\n2  3  c\n```\n\n\n:::\n\n```{.python .cell-code}\n# Select a single column as a Series (simplifies by default)\nprint(df['x'])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0    1\n1    2\n2    3\nName: x, dtype: int64\n```\n\n\n:::\n\n```{.python .cell-code}\n# Select a single column as a DataFrame (does not simplify)\nprint(df[['x']])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   x\n0  1\n1  2\n2  3\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n### List\n\n::: {.panel-tabset}\n\n## R\n\nThere are two other subsetting operators: `[[` and `$`. `[[` is used for extracting single items, while `x$y` is a useful shorthand for `x[[\"y\"]]`.\n\n`[[` is most important when working with lists because subsetting a list with `[` always returns a smaller list. To help make this easier to understand we can use a metaphor:\n\n`[[` can return only a single item, you must use it with either a single positive integer or a single string.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(a = 1:3, b = \"a\", d = 4:6)\n\n# Get the subset \nx[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(x[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 1\n $ a: int [1:3] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\nx[1:2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n[1] 1 2 3\n\n$b\n[1] \"a\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Get the element\nx[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(x[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 1\n $ a: int [1:3] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\n# with Label\nx$a\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\nx[[\"a\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n\n\n\n## Python\n\nIn Python there are no effectiv ways to create a items named list. It can always get the element of the list but not a subset of the list.\n\nIn Python, there are no effective ways to create items with named elements in a list. While you can access individual elements by their positions, there isn't a straightforward method to create a subset of the list with named elements. \n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Create a Python list with nested lists\nx = [list(range(1, 4)), \"a\", list(range(4, 7))]\n\n# Get the subset (Python list slice)\nprint([x[0]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1, 2, 3]]\n```\n\n\n:::\n\n```{.python .cell-code}\n# Get the element using list indexing\nprint(x[0])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 2, 3]\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(type(x[0]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'list'>\n```\n\n\n:::\n:::\n\n\n\n\nHowever, dictionaries in Python excel in this regard, as they allow you to assign and access elements using user-defined keys, providing a more efficient way to work with named elements and subsets of data.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Create a dictionary with labels\nx = {\"a\": list(range(1, 4)), \"b\": \"a\", \"d\": list(range(4, 7))}\n\n\n# Get the element using dictionary indexing\nprint(x[\"a\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 2, 3]\n```\n\n\n:::\n\n```{.python .cell-code}\n# Access an element with a label\nprint(x[\"a\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 2, 3]\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(x.get(\"a\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 2, 3]\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(type(x[\"a\"]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'list'>\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n## Data CRUD\n\nData manipulation is the art and science of transforming raw data into a more structured and useful format for analysis, interpretation, and decision-making. It's a fundamental process in data science, analytics, and database management.\n\nOperations for creating and managing persistent data elements can be summarized as CRUD:\n\n1. **Create (Add):** The creation of new data elements or records.\n\n2. **Read:** The retrieval and access of existing data elements for analysis or presentation.\n\n3. **Update:** The modification or editing of data elements to reflect changes or corrections.\n\n4. **Delete:** The removal or elimination of data elements that are no longer needed or relevant.\n\nCombining CRUD operations with subsetting provides a powerful toolkit for working with data, ensuring its accuracy, relevance, and utility in various applications, from database management to data analysis.\n\n### Create & Add\n\nMost of the original data we work with is often loaded from external data sources or files. This process will be discussed in detail in the article titled [Data Load](data_load.qmd). \n\nIn this section, we will focus on the fundamental aspects of creating and adding data, which may have already been mentioned several times in the preceding text.\n\n\n::: {.panel-tabset}\n\n## R\n\nCreating new objects in R is commonly done using the assignment operator `<-`. \n\n\nWhen it comes to vectors or list, there are two primary methods to append new elements:\n\n- `c()`: allows you to combine the original vector with a new vector or element, effectively extending the vector.\n\n- `append()`: enables you to append a new vector or element at a specific location within the original vector.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Automic value\na <- 1 / 200 * 30\n\n# vector\nx_v <- c(2.1, 4.2, 3.3, 5.4)\n# List\nx_l <- list(a = 1:3, b = \"a\", d = 4:6)\n# add new elements\nc(x_v, c(-1,-5.6))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2.1  4.2  3.3  5.4 -1.0 -5.6\n```\n\n\n:::\n\n```{.r .cell-code}\nc(x_l, list(e = c(TRUE, FALSE)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n[1] 1 2 3\n\n$b\n[1] \"a\"\n\n$d\n[1] 4 5 6\n\n$e\n[1]  TRUE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# append after 2. Element\nappend(x_v, c(-1,-5.6), 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2.1  4.2 -1.0 -5.6  3.3  5.4\n```\n\n\n:::\n\n```{.r .cell-code}\nappend(x_l, list(e = c(TRUE, FALSE)), 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n[1] 1 2 3\n\n$b\n[1] \"a\"\n\n$e\n[1]  TRUE FALSE\n\n$d\n[1] 4 5 6\n```\n\n\n:::\n:::\n\n\n\n\nWhen working with 2D matrices or data frames in R, you can use the following functions to add new elements in the row or column dimensions:\n\n- `cbind()`: to combine data frames or matrices by adding new columns.\n\n- `rbind()`: to combine data frames or matrices by adding new rows.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a matrix\nx_m <- matrix(1:9, nrow = 3)\n# data frame\ndf <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\n# append in colum dimension\ncbind(x_m, -1:-3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   -1\n[2,]    2    5    8   -2\n[3,]    3    6    9   -3\n```\n\n\n:::\n\n```{.r .cell-code}\ncbind(df, k = -1:-3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y z  k\n1 1 3 a -1\n2 2 2 b -2\n3 3 1 c -3\n```\n\n\n:::\n\n```{.r .cell-code}\n# append in row dimension\nrbind(x_m, -1:-3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n[4,]   -1   -2   -3\n```\n\n\n:::\n\n```{.r .cell-code}\nrbind(df, list(-1, -2, \"z\")) # try with rbind(df, c(-1, -2, \"z\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   x  y z\n1  1  3 a\n2  2  2 b\n3  3  1 c\n4 -1 -2 z\n```\n\n\n:::\n:::\n\n\n\n\nAdditionally, for both lists and data frames in R, you can use the `$ <- ` operator to add new elements:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Data frame\ndf <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\ncbind(df, k = -1:-3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y z  k\n1 1 3 a -1\n2 2 2 b -2\n3 3 1 c -3\n```\n\n\n:::\n\n```{.r .cell-code}\ndf$k <- -1:-3 # same to df[['k']] <- -1:-3\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y z  k\n1 1 3 a -1\n2 2 2 b -2\n3 3 1 c -3\n```\n\n\n:::\n\n```{.r .cell-code}\n# List\nx_l <- list(a = 1:3, b = \"a\", d = 4:6)\nc(x_l, list(e = c(TRUE, FALSE)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n[1] 1 2 3\n\n$b\n[1] \"a\"\n\n$d\n[1] 4 5 6\n\n$e\n[1]  TRUE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nx_l$e <- c(TRUE, FALSE) # same to x_l[['e']] <- c(TRUE, FALSE)\nx_l\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n[1] 1 2 3\n\n$b\n[1] \"a\"\n\n$d\n[1] 4 5 6\n\n$e\n[1]  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n## Python\n\nCreating new objects in Python is often accomplished using the assignment operator `=`. When it comes to adding elements to list, there are three primary functions to consider:\n\n- `append()`: add a single element to the end of a list.\n\n- `insert()`: add an element at a specific position within a list.\n\n- `extend()` same as `+`: append elements from an iterable (e.g., another list) to the end of an existing list, allowing for the expansion of the list with multiple elements.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Atomic element\na = 1 / 200 * 30\nb = a + 1\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0.15\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1.15\n```\n\n\n:::\n\n```{.python .cell-code}\n# List\nx = [2.1, 4.2, 3.3, 5.4]\n\n# Append on element\nx.append(-1)\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[2.1, 4.2, 3.3, 5.4, -1]\n```\n\n\n:::\n\n```{.python .cell-code}\n# Insert on eelement\nx.insert(3, -5.6)\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[2.1, 4.2, 3.3, -5.6, 5.4, -1]\n```\n\n\n:::\n\n```{.python .cell-code}\n# Extend with new list\nx.extend([6.7, 7.9])\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[2.1, 4.2, 3.3, -5.6, 5.4, -1, 6.7, 7.9]\n```\n\n\n:::\n:::\n\n\n\n\nWhen working with `numpy.array` in Python, you can add elements in two primary ways:\n\n- `append()`: add element or a new numpy array to the end.\n\n- `insert()`: insert element or a new numpy array at specific locations within the original numpy array.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n\n# Create a NumPy array\nx_a = np.array([2.1, 4.2, 3.3, 5.4])\n\nprint(np.append(x_a, -1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[ 2.1  4.2  3.3  5.4 -1. ]\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(np.append(x_a, np.array([6.7, 7.9])))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[2.1 4.2 3.3 5.4 6.7 7.9]\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(np.insert(x_a, 3, -5.6))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[ 2.1  4.2  3.3 -5.6  5.4]\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(np.insert(x_a, 3, np.array([6.7, 7.9])))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[2.1 4.2 3.3 6.7 7.9 5.4]\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n\n### Read \n\nThe **read** process is essentially a form of subsetting, where you access specific elements or subsets of data using their indexes. The crucial aspect of this operation is how to obtain and utilize these indexes effectively.\n\n::: {.panel-tabset}\n\n## R\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a DataFrame\ndf <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\n\n# Access using integer index \ndf[1,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\n# Access using names index\ndf[,\"z\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\" \"b\" \"c\"\n```\n\n\n:::\n\n```{.r .cell-code}\ndf$z\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\" \"b\" \"c\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Access with a value condition\nidx <- which(df$x > 1)\ndf[idx,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y z\n2 2 2 b\n3 3 1 c\n```\n\n\n:::\n\n```{.r .cell-code}\ndf[idx, \"z\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"b\" \"c\"\n```\n\n\n:::\n\n```{.r .cell-code}\nidx <- which(df$z == \"a\")\ndf[idx,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y z\n1 1 3 a\n```\n\n\n:::\n\n```{.r .cell-code}\ndf[idx, 1:2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y\n1 1 3\n```\n\n\n:::\n:::\n\n\n\n\n## Python\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\n\n# Create a pandas DataFrame\ndf = pd.DataFrame({'x': range(1, 4), 'y': range(3, 0, -1), 'z': list('abc')})\n\n# Access using integer index (iloc)\nprint(df.iloc[0, 1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3\n```\n\n\n:::\n\n```{.python .cell-code}\n# Access using column label\nprint(df['z'])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0    a\n1    b\n2    c\nName: z, dtype: object\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(df.z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0    a\n1    b\n2    c\nName: z, dtype: object\n```\n\n\n:::\n\n```{.python .cell-code}\n# Access with a value condition\nidx = df['x'] > 1\nprint(df[idx])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   x  y  z\n1  2  2  b\n2  3  1  c\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(df[df['z'] == 'a'])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   x  y  z\n0  1  3  a\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(df[df['z'] == 'a'][['x', 'y']])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   x  y\n0  1  3\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n### Update\n\nThe **update** operation builds upon the principles of reading. It involves replacing an existing value with a new one, but with certain constraints. The new value must have the same data type, size, and structure as the original value. This ensures data consistency and integrity when modifying data elements. About \"data type\" it is not so strength, somtimes it is chanable if you replace the whol e.g. colums in data frame.\n\nIt's important to note that the concept of 'data type' isn't always rigid. There are cases where data types can change, particularly when replacing entire columns in a data frame, for instance. While data types typically define the expected format and behavior of data, specific operations and transformations may lead to changes in data types to accommodate new values or structures.\n\n::: {.panel-tabset}\n\n## R\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a DataFrame\ndf <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y z\n1 1 3 a\n2 2 2 b\n3 3 1 c\n```\n\n\n:::\n\n```{.r .cell-code}\n# Update using integer index \ndf[1,2] <- 0\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y z\n1 1 0 a\n2 2 2 b\n3 3 1 c\n```\n\n\n:::\n\n```{.r .cell-code}\n# Update using names index\ndf[2,\"z\"] <- \"lk\"\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y  z\n1 1 0  a\n2 2 2 lk\n3 3 1  c\n```\n\n\n:::\n\n```{.r .cell-code}\n# Update with a value condition\nidx <- which(df$x > 1)\ndf[idx, \"z\"] <- \"bg1\"\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y   z\n1 1 0   a\n2 2 2 bg1\n3 3 1 bg1\n```\n\n\n:::\n\n```{.r .cell-code}\nidx <- which(df$z == \"a\")\ndf[idx,] <- c(-1, -5, \"new_a\")\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   x  y     z\n1 -1 -5 new_a\n2  2  2   bg1\n3  3  1   bg1\n```\n\n\n:::\n:::\n\n\n\n\n## Python\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\n\n# Create a pandas DataFrame\ndf = pd.DataFrame({'x': range(1, 4), 'y': range(3, 0, -1), 'z': list('abc')})\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   x  y  z\n0  1  3  a\n1  2  2  b\n2  3  1  c\n```\n\n\n:::\n\n```{.python .cell-code}\n# Update using integer index\ndf.iat[0, 1] = 0\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   x  y  z\n0  1  0  a\n1  2  2  b\n2  3  1  c\n```\n\n\n:::\n\n```{.python .cell-code}\n# Update using column label and row index\ndf.at[1, 'z'] = \"lk\"\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   x  y   z\n0  1  0   a\n1  2  2  lk\n2  3  1   c\n```\n\n\n:::\n\n```{.python .cell-code}\n# Update with a value condition\nidx_x_gt_1 = df['x'] > 1\ndf.loc[idx_x_gt_1, 'z'] = \"bg1\"\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   x  y    z\n0  1  0    a\n1  2  2  bg1\n2  3  1  bg1\n```\n\n\n:::\n\n```{.python .cell-code}\nidx_z_eq_a = df['z'] == 'a'\ndf.loc[idx_z_eq_a] = [-1, -5, \"new_a\"]\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   x  y      z\n0 -1 -5  new_a\n1  2  2    bg1\n2  3  1    bg1\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n\n\n### Delete\n\n::: {.panel-tabset}\n\n## R\n\nDeletion in R can be accomplished relatively easily using methods like specifying **negative integer** indices or setting elements to `NULL` within a list. However, it's essential to recognize that there are limitations to deletion operations. For instance, when dealing with multi-dimensional arrays, you cannot delete a single element in the same straightforward manner; instead, you can only delete entire sub-dimensions. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a DataFrame\ndf <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y z\n1 1 3 a\n2 2 2 b\n3 3 1 c\n```\n\n\n:::\n\n```{.r .cell-code}\n# Delete using negative integer index \ndf[,-2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x z\n1 1 a\n2 2 b\n3 3 c\n```\n\n\n:::\n\n```{.r .cell-code}\ndf[-2,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y z\n1 1 3 a\n3 3 1 c\n```\n\n\n:::\n\n```{.r .cell-code}\n# Setting elements to `NULL`\ndf$y <- NULL\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x z\n1 1 a\n2 2 b\n3 3 c\n```\n\n\n:::\n:::\n\n\n\n\n## Python\n\nIn Python is to use the `.drop()` command to delete the elemnts in datatframe. More details in [pandas document](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.drop.html)\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndf = pd.DataFrame({'x': range(1, 4), 'y': range(3, 0, -1), 'z': list('abc')})\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   x  y  z\n0  1  3  a\n1  2  2  b\n2  3  1  c\n```\n\n\n:::\n\n```{.python .cell-code}\n# Drop columns\nprint(df.drop(['x', 'z'], axis=1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   y\n0  3\n1  2\n2  1\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(df.drop(columns=['x', 'y']))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   z\n0  a\n1  b\n2  c\n```\n\n\n:::\n\n```{.python .cell-code}\n# Drop a row by index\nprint(df.drop([0, 1]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   x  y  z\n2  3  1  c\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n\n\n# Coding {#sec-coding}\n\n## Math \n\n- '+' '-' '*' '/'\n- Exponent, Logarithm\n- Trigonometric functions\n- Linear algebra, Matrix multiplication\n\n::: {.panel-tabset}\n\n## R\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 / 200 * 30\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.15\n```\n\n\n:::\n\n```{.r .cell-code}\n(59 + 73 - 2) / 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 43.33333\n```\n\n\n:::\n\n```{.r .cell-code}\n3^2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 9\n```\n\n\n:::\n\n```{.r .cell-code}\nsin(pi / 2) # pi as Const number in R\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\n\n## Python\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nprint(1 / 200 * 30)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0.15\n```\n\n\n:::\n\n```{.python .cell-code}\nprint((59 + 73 - 2) / 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n43.333333333333336\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(3**2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n9\n```\n\n\n:::\n\n```{.python .cell-code}\nimport math\nprint(math.sin(math.pi/2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1.0\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n## Control flow\n\nThere are two primary tools of control flow: choices and loops. \n\n- **Choices**, like `if` statements calls, allow you to run different code **depending on the input**. \n- **Loops**, like for and while, allow you to **repeatedly** run code, typically with changing options.\n\n### choices \n\n#### Basic If-Else\n\n::: {.panel-tabset}\n\n## R\n\nThe basic form of an if statement in R is as follows:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (condition) {\n  true_action\n}\nif (condition) {\n  true_action\n} else {\n  false_action\n}\n```\n:::\n\n\n\n\nIf `condition` is `TRUE`, `true_action` is evaluated; if `condition` is `FALSE`, the optional `false_action` is evaluated. \n\nTypically the actions are compound statements contained within `{`:\n\n`if` returns a value so that you can assign the results:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 6\nb <- 8\n\nif (b > a) {\n  cat(\"b is greater than a\\n\")\n} else if (a == b) {\n  cat(\"a and b are equal\\n\")\n} else {\n  cat(\"a is greater than b\\n\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nb is greater than a\n```\n\n\n:::\n:::\n\n\n\n\n## Python\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# if statements\nif condition: \n  true_action\n  \n# if-else\nif condition: \n  true_action \nelse: \n  false_action\n\n\n# if-ifel-else\nif condition1: \n  true_action1 \nelif condition2: \n  true_action2 \nelse: \n  false_action\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\na = 6\nb = 8\nif b > a:\n  print(\"b is greater than a\")\nelif a == b:\n  print(\"a and b are equal\")\nelse:\n  print(\"a is greater than b\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nb is greater than a\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n\n#### switch\n\n::: {.panel-tabset}\n\n## R\n\nClosely related to `if` is the `switch()`-statement. It's a compact, special purpose equivalent that lets you replace code like:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_option <- function(x) {\n  if (x == \"a\") {\n    \"option 1\"\n  } else if (x == \"b\") {\n    \"option 2\" \n  } else if (x == \"c\") {\n    \"option 3\"\n  } else {\n    stop(\"Invalid `x` value\")\n  }\n}\n```\n:::\n\n\n\n\nwith the more succinct:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_option <- function(x) {\n  switch(x,\n    a = \"option 1\",\n    b = \"option 2\",\n    c = \"option 3\",\n    stop(\"Invalid `x` value\")\n  )\n}\nx_option(\"b\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"option 2\"\n```\n\n\n:::\n:::\n\n\n\n\nThe last component of a `switch()` should always throw an error, otherwise unmatched inputs will invisibly return `NULL`:\n\n\n## Python\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmatch subject:\n    case <pattern_1>:\n        <action_1>\n    case <pattern_2>:\n        <action_2>\n    case <pattern_3>:\n        <action_3>\n    case _:\n        <action_wildcard>\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ndef x_option(x):\n    options = {\n        \"a\": \"option 1\",\n        \"b\": \"option 2\",\n        \"c\": \"option 3\"\n    }\n    return options.get(x, \"Invalid `x` value\")\n\nprint(x_option(\"b\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\noption 2\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n\n#### Vectorised if\n\n::: {.panel-tabset}\n\n## R\n\nGiven that `if` only works with a single `TRUE` or `FALSE`, you might wonder what to do if you have a vector of logical values. Handling vectors of values is the job of `ifelse()`: a vectorised function with `test`, `yes`, and `no` vectors (that will be recycled to the same length):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\nifelse(x %% 5 == 0, \"XXX\", as.character(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"1\"   \"2\"   \"3\"   \"4\"   \"XXX\" \"6\"   \"7\"   \"8\"   \"9\"   \"XXX\"\n```\n\n\n:::\n\n```{.r .cell-code}\nifelse(x %% 2 == 0, \"even\", \"odd\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\"\n```\n\n\n:::\n:::\n\n\n\n\nNote that missing values will be propagated into the output.\n\nI recommend using `ifelse()` only when the `yes` and `no` vectors are the same type as it is otherwise hard to predict the output type. See <https://vctrs.r-lib.org/articles/stability.html#ifelse> for additional discussion.\n\n\n## Python\n\n:::\n\n\n### Loops\n\n#### `for`-Loops\n\nA for loop is used for iterating over a sequence (that is either a list, a tuple, a dictionary, a set, or a string).\nFor each item in `vector`, `perform_action` is called once; updating the value of `item` each time.\n\n::: {.panel-tabset}\n\n## R\n\nIn R, `for` loops are used to iterate over items in a vector. They have the following basic form:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (item in vector) perform_action\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:3) {\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 2\n[1] 3\n```\n\n\n:::\n:::\n\n\n\n\n\n## Python\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfor item in vector \n  perform_action\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nfor i in range(1, 3):\n  print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1\n2\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n\n#### `while`-Loops\n\nWith the while loop we can execute a set of statements as long as a condition is `TRUE`:\n\n::: {.panel-tabset}\n\n## R\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 1\nwhile (i < 6) {\n  print(i)\n  i <- i + 1\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n```\n\n\n:::\n:::\n\n\n\n\n\n## Python\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ni = 1\nwhile i < 6:\n  print(i)\n  i += 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1\n2\n3\n4\n5\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n\n\n#### terminate \n\n::: {.panel-tabset}\n\n## R\n\nThere are two ways to terminate a `for` loop early:\n\n* `next` exits the current iteration.\n* `break` exits the entire `for` loop.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:10) {\n  if (i < 3) \n    next\n\n  print(i)\n  \n  if (i >= 5)\n    break\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n[1] 4\n[1] 5\n```\n\n\n:::\n:::\n\n\n\n\n\n## Python\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfor i in range(1, 10):\n    if i < 3:\n        continue\n    \n    print(i)\n    \n    if i >= 5:\n        break\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3\n4\n5\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n\n## Function\n\nMore details of in [Advanced R Chapter 6](https://adv-r.hadley.nz/functions.html)\n\nA function is a block of code which only runs when it is called.\nIt can be broken down into three components:\n\n* The `formals()`, the list of **arguments** that control how you call the function.\n  \n* The `body()`, the **code** inside the function.\n\n* The `environment()`, the data structure that determines how the function **finds** \nthe values associated with the **names**.\n\nWhile the formals and body are specified explicitly when you create a function, the environment is specified implicitly, based on _where_ you defined the function. This location could be within another package or within the workspace (global environment).\n\n::: {.panel-tabset}\n\n## R\n\nThe function environment always exists, but it is only printed when the function isn't defined in the global environment.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfct_add <- function(x, y) {\n  # A comment\n  x + y\n}\n\n# Get the formal arguments\nformals(fct_add)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$x\n\n\n$y\n```\n\n\n:::\n\n```{.r .cell-code}\n# Get the function's source code (body)\nbody(fct_add)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{\n    x + y\n}\n```\n\n\n:::\n\n```{.r .cell-code}\n# Get the function's global environment (module-level namespace)\nenvironment(fct_add)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<environment: R_GlobalEnv>\n```\n\n\n:::\n:::\n\n\n\n\n## Python\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef fct_add(x, y):\n    # A comment\n    return x + y\n\n# Get the formal arguments\nprint(fct_add.__code__.co_varnames)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n('x', 'y')\n```\n\n\n:::\n\n```{.python .cell-code}\n# Get the function's source code (body)\nprint(fct_add.__code__.co_code)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nb'\\x97\\x00|\\x00|\\x01z\\x00\\x00\\x00S\\x00'\n```\n\n\n:::\n\n```{.python .cell-code}\n# Get the function's global environment (module-level namespace)\nprint(fct_add.__globals__)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, 'r': <__main__.R object at 0x0000018FFF41EA10>, 'x': [2.1, 4.2, 3.3, -5.6, 5.4, -1, 6.7, 7.9], 'y': 1.0, 'np': <module 'numpy' from 'C:\\\\Users\\\\lei\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\PYTHON~1\\\\Lib\\\\site-packages\\\\numpy\\\\__init__.py'>, 'pd': <module 'pandas' from 'C:\\\\Users\\\\lei\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\PYTHON~1\\\\Lib\\\\site-packages\\\\pandas\\\\__init__.py'>, 'vct_Test': [1, 5, 7], 'ary_Test': array([[[ 1,  2,  3,  4],\n        [ 5,  6,  7,  8],\n        [ 9, 10, 11, 12]],\n\n       [[13, 14, 15, 16],\n        [17, 18, 19, 20],\n        [21, 22, 23, 24]]]), 'mat_Test': array([[ 1,  2,  3,  4],\n       [ 5,  6,  7,  8],\n       [ 9, 10, 11, 12],\n       [13, 14, 15, 16],\n       [17, 18, 19, 20],\n       [21, 22, 23, 24]]), 'lst_Test': [[1, 3, 5], 'abc', False], 'df_Test':   name  age\n0  Bob   12\n1  Tom   13, 'a2': array([[1, 2, 3],\n       [4, 5, 6],\n       [7, 8, 9]]), 'colnames': ['A', 'B', 'C'], 'a3': array([[[ 1,  2,  3,  4],\n        [ 5,  6,  7,  8],\n        [ 9, 10, 11, 12]],\n\n       [[13, 14, 15, 16],\n        [17, 18, 19, 20],\n        [21, 22, 23, 24]]]), 'df':    x  y  z\n0  1  3  a\n1  2  2  b\n2  3  1  c, 'a': 6, 'b': 8, 'x_a': array([2.1, 4.2, 3.3, 5.4]), 'idx': 0    False\n1     True\n2     True\nName: x, dtype: bool, 'idx_x_gt_1': 0    False\n1     True\n2     True\nName: x, dtype: bool, 'idx_z_eq_a': 0     True\n1    False\n2    False\nName: z, dtype: bool, 'math': <module 'math' (built-in)>, 'x_option': <function x_option at 0x0000018F924FFCE0>, 'i': 5, 'fct_add': <function fct_add at 0x0000018F924D9DA0>}\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n\n\n### Call\n\n::: {.panel-tabset}\n\n## R\n\nCalling Syntax:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction_name(argument1 = value1, argument2 = value2, ...)\n```\n:::\n\n\n\n\n\nTry using `seq()`, which makes regular **seq**uences of numbers:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(from = 1, to = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n:::\n\n\n\n\nWe often omit the names of the first several arguments in function calls, so we can rewrite this as follows:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(1, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n:::\n\n\n\n\nWe can also check the arguments and other information with:\n\n```{.r}\n?seq\n```\n\nThe \"help\" windows shows as:\n\n![](../images/r-help.png)\n\n## Python\n\nCalling Syntax:\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfunction_name(argument1 = value1, argument2 = value2)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nsequence = list(range(1, 11))\nprint(sequence)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n\n### Define \n\n::: {.panel-tabset}\n\n## R\n\nUse the function() keyword:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_add1 <- function(x) {\n  x + 1\n}\n```\n:::\n\n\n\n\ncalling the function `my_add1`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_add1(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n\n\n::: {.callout-tip}\nIn R, the return statement is not essential for a function to yield a value as its result. By default, R will return the result of the last command within the function as its output.\n:::\n\n\n## Python\n\nIn Python a function is defined using the `def` keyword:\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef my_add(x):\n  return x + 1\n```\n:::\n\n\n\n\ncalling the function `my_add1`:\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nprint(my_add(2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3\n```\n\n\n:::\n:::\n\n\n\n\n\n::: {.callout-important}\nThe `return` statement is essential for a function to yield a value as its result.\n\n:::\n:::\n\n\n# Naming {#sec-naming}\n\n\n\n## Naming rules\n\n\n::: {.panel-tabset}\n\n## R\n\n- must start with a letter\n- can only contain letters, numbers, underscores `_`, and dot `.`\n- case-sensitive (age, Age and AGE are three different variables)\n- cannot be any of the Reserved Words\n  - `TRUE` `FALSE`\n  - `NULL` `Inf` `NaN` `NA` `NA_real` `NA_complex_` `NA_character_`\n  - `if` `else`\n  - `for` `while` `repeat` \n  - `next` `break`\n  - `function` \n  - `in`\n\n\n:::: {.columns}\n\n::: {.column width=\"48%\"}\n::: {.callout-tip}\n## Legal \n\ni_use_snake_case\n\notherPeopleUseCamelCase\n\nsome.people.use.periods\n\naFew.People_RENOUNCEconvention6\n:::\n\n:::\n\n::: {.column width=\"4%\"}\n:::\n\n::: {.column width=\"48%\"}\n::: {.callout-important}\n## Illegal \n\n_start_with_underscores\n\n1_start_with_number\n\nif\n\ncontain sapce\n\ncontain-other+charater\n\n:::\n\n:::\n\n::::\n\nmore Reserved Words in:\n\n```{.r}\nhelp(\"reserved\")\n```\n\n\n## Python\n\n- must start with a letter or the **underscore character `_`**\n- can only contain letters, numbers, and underscores `_` \n- case-sensitive (age, Age and AGE are three different variables)\n- cannot be any of the Python keywords (35 keywors in Python 3.8)\n  - `True` `False`\n  - `None` \n  - `if` `else` `elif`\n  - `for` `while` `repeat` \n  - `try` `break` `continue` `finally`\n  - `def`\n  - `in` `and` `or` `not`\n  - `return`\n\n:::: {.columns}\n\n::: {.column width=\"48%\"}\n::: {.callout-tip}\n## Legal \n\ni_use_snake_case\n\n_start_with_underscores\n\notherPeopleUseCamelCase\n\n\naFew_People_RENOUNCEconvention6\n:::\n\n:::\n\n::: {.column width=\"4%\"}\n:::\n\n::: {.column width=\"48%\"}\n::: {.callout-important}\n## Illegal \n\nwant.contain.dot\n\n1_start_with_number\n\nif\n\ncontain sapce\n\ncontain-other+charater\n\n:::\n\n:::\n\n::::\n\nMore Keywords in:\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nhelp(\"keywords\")\n```\n:::\n\n\n\n\n:::\n\n## Naming Conventions \n\n- **Camel Case**\n  - Each word, except the first, starts with a capital letter:\n  - `myVariableName` \n- **Pascal Case**\n  - Each word starts with a capital letter:\n  - `MyVariableName` \n- **Snake Case**\n  - Each word is separated by an underscore character:\n  - `my_variable_name` \n\n\n\n\n",
    "supporting": [
      "basic_r_python_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}