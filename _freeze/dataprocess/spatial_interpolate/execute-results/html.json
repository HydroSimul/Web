{
  "hash": "9baebede7b25c5af5d17cb184bd0e1e3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Spatial Interpolation\nexecute:\n  warning: false\n  error: false\nsidebar:\n  contents: auto\nnumber-sections: true\n---\n\n\n\n\n\n# Theory\n\nSpatial interpolation is the process of estimating values at unmeasured locations based on observations from nearby points. In this section, we introduce several commonly used approaches.\n\n## Weighted Mean Concept in Spatial Interpolation\n\nMost spatial interpolation methods, from the simplest global mean to nearest-neighbor, IDW, and Kriging, can be understood within a **weighted-mean framework**. The estimated value at an unmeasured location $x_0$ is a weighted sum of observed values:\n\n$$\n\\hat{z}(x_0) = \\sum_{i=1}^{n} \\lambda_i z_i\n$$\n\nwhere $\\lambda_i$ is the weight assigned to observation $i$.  \n\n- In the **global mean**, all observations are equally weighted: $\\lambda_i = 1/n$.  \n- In **nearest-neighbor** methods, only the closest points have non-zero weight: $\\lambda_i = 1/k$.  \n- In **inverse distance weighting (IDW)**, weights decrease with distance: $\\lambda_i \\propto 1/d_i^p$.  \n- In **Kriging**, weights are chosen to minimize estimation variance while accounting for spatial correlation and ensuring unbiasedness.  \n\nThus, every interpolation method can be interpreted as **defining a specific set of weights $\\lambda_i$** to combine observed values into an estimate. In the following sections, we will focus primarily on calculating the weights $\\lambda_i$, as the weighted mean step itself is straightforward.\n\nSymbols used:\n\n- $x_0$ : location of the unmeasured point  \n- $x_i$ : location of the $i$-th observed point  \n- $\\lambda_i$ : weight for observation $i$  \n- $z_i$ : observed value at location $x_i$  \n- $\\hat{z}(x_0)$ : estimated value at location $x_0$  \n- $n$ : total number of observed points  \n- $k$ : number of nearest neighbors considered  \n- $d_i$ : distance between $x_0$ and $x_i$  \n- $p$ : distance weighting power (for IDW)  \n- $\\gamma(h)$ : semivariance for lag distance $h$ in the variogram  \n- $\\mu$ : Lagrange multiplier in ordinary Kriging  \n\nLibraries and Data used:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# LIBRARY\nlibrary(tidyverse)\ntheme_set(theme_bw())\nlibrary(gstat)\nlibrary(terra)\nlibrary(tidyterra)\nlibrary(patchwork)\n# DATEN\nvct_Boundry_NRW <- vect(\"../data_share/vct_Boundry_NRW.geojson\") # |> project(\"EPSG:25832\")\nvct_Station_NRW_S10 <- vect(\"../data_share/vct_Station_NRW_S10.geojson\") # |> project(\"EPSG:25832\")\nvct_Station_NRW_S50 <- vect(\"../data_share/vct_Station_NRW_S50.geojson\") # |> project(\"EPSG:25832\")\nvct_Segment_S10    <- vect(\"../data_share/vct_Segment_S10.geojson\") # |> project(\"EPSG:25832\")\nvct_Point_Unknow   <- vect(\"../data_share/vct_Point_Unknow.geojson\") # |> project(\"EPSG:25832\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ncolor_RUB_blue <- \"#17365c\"\ncolor_RUB_green <- \"#8dae10\"\ncolor_TUD_middleblue <- \"#006ab2\"\ncolor_TUD_lightblue <- \"#009de0\"\ncolor_TUD_green <- \"#007d3f\"\ncolor_TUD_lightgreen <- \"#69af22\"\ncolor_TUD_orange <- \"#ee7f00\"\ncolor_TUD_pink <- \"#EC008D\"\ncolor_TUD_purple <- \"#54368a\"\ncolor_TUD_redpurple <- \"#93107d\"\ncolor_SafetyOrange <- \"#ff5e00\"\ncolor_DRESDEN <- c(\"#03305D\", \"#28618C\", \"#539DC5\", \"#84D1EE\", \"#009BA4\", \"#13A983\", \"#93C356\", \"#BCCF02\")\n```\n:::\n\n\n\n\nTo illustrate the concepts of different spatial interpolation approaches, we use the mean annual precipitation (1981–2010) recorded at 10 gauges in North Rhine-Westphalia (NRW).  \n\n- The **orange point** represents an unmeasured location, whose precipitation value is to be estimated using various interpolation methods.  \n- The **orange lines** connect this unmeasured point to the observation stations utilized by each method.  \n- The **labels on the lines** indicate the corresponding weights $\\lambda_i$ assigned to each station in the interpolation process.\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](spatial_interpolate_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\n\n## Null Model (Global Mean)\n\nThe simplest model assumes that the value at any unmeasured location is equal to the mean of all observed values. Within the weighted mean framework, all weights are equal:\n\n$$\n\\lambda_i = \\frac{1}{n} \\quad \\text{for all } i\n$$\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnum_GlobalMean <- vct_Station_NRW_S10$NiederschlagJahr |> mean()\nnum_GlobalMean\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 928.1\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](spatial_interpolate_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Nearest Neighbor (1-nearest)\n\nThis method assigns the value of the closest observation to the unmeasured location. Within the weighted mean framework, only the nearest point has weight 1, while all others have weight 0:\n\n$$\n\\lambda_i =\n\\begin{cases}\n1 & \\text{if } x_i \\text{ is the nearest point} \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nidx_Near1 <- order(vct_Segment_S10$length_km)[1]\nnum_Near1 <- vct_Station_NRW_S10$NiederschlagJahr[idx_Near1]\nnum_Near1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 778.9\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](spatial_interpolate_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## k-Nearest Neighbors\n\nThis method estimates the value at an unmeasured location using the average of the $k$ nearest observations. Within the weighted mean framework, each of the $k$ nearest neighbors is assigned equal weight:\n\n$$\n\\lambda_i =\n\\begin{cases}\n\\frac{1}{k} & \\text{if } x_i \\text{ is among the $k$ nearest} \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nidx_Near5 <- order(vct_Segment_S10$length_km)[1:4]\nnum_Near5 <- vct_Station_NRW_S10$NiederschlagJahr[idx_Near5] |> mean()\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](spatial_interpolate_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Inverse Distance Weighting (IDW)\n\nIn this method, the weight of each observation is inversely proportional to its distance from the unmeasured location:\n\n$$\n\\lambda_i = \\frac{d_i^{-p}}{\\sum_{j=1}^{n} d_j^{-p}}\n$$\n\nwhere $d_i$ is the distance between the unmeasured location and observation $i$, and $p$ is the distance weighting power, which controls how quickly weights decrease with distance.\n\n\n\n**Note:** A larger value of $p$ assigns more weight to closer points. Typically, $p = 1$ is used.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnum_IDW_ID <- 1/(vct_Segment_S10$length_km[idx_Near5])\nnum_IDW_Weight <- round(num_IDW_ID / sum(num_IDW_ID), 3)\nnum_IDW <- sum(vct_Station_NRW_S10$NiederschlagJahr[idx_Near5] * num_IDW_Weight)\nnum_IDW\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 971.208\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](spatial_interpolate_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n## Ordinary Kriging\n\nOrdinary Kriging is a geostatistical interpolation method that estimates values at unmeasured locations by accounting for the spatial correlation between observations. It computes location-specific weights $\\lambda_i$ using the **semivariogram** $\\gamma(h)$, ensuring that the estimator is unbiased and has **minimum estimation variance**.\n\nUnlike previous methods (mean, nearest neighbor, IDW), where the weights depend only on distances between the unmeasured point and observed stations, Kriging weights are derived from the **spatial structure of the variable itself**. This means that for different variables (e.g., precipitation, temperature, soil moisture), even with the same observation locations, the Kriging weights will differ because the spatial correlation patterns are different.\n\n### Fitting the Variogram\n\nThe variogram $\\gamma(h)$ describes how data similarity decreases with increasing distance $h$. It is estimated from the observed data using pairs of points separated by approximately the same distance:\n\n$$\n\\gamma(h) = \\frac{1}{2|N(h)|} \\sum_{(i,j) \\in N(h)} (z_i - z_j)^2\n$$\n\nwhere $N(h)$ is the set of all pairs of points separated by lag distance $h$.\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell fig-fullwidth='true'}\n::: {.cell-output-display}\n![](spatial_interpolate_files/figure-html/unnamed-chunk-13-1.png){width=1152}\n:::\n:::\n\n\n\n\n\nAfter computing the empirical variogram, a theoretical model is fitted to describe the spatial dependence. Common variogram models include:\n\n1. **Exponential**\n\n$$\n\\gamma(h) = \n\\begin{cases}\nc_0 + c \\left(1 - \\exp\\left(-\\frac{h}{a}\\right)\\right), & h > 0 \\\\\n0, & h = 0\n\\end{cases}\n$$\n\n2. **Spherical**\n\n$$\n\\gamma(h) =\n\\begin{cases}\nc_0 + c \\left(\\frac{3h}{2a} - \\frac{1}{2} \\left(\\frac{h}{a}\\right)^3 \\right), & 0 < h \\le a \\\\\nc_0 + c, & h > a \\\\\n0, & h = 0\n\\end{cases}\n$$\n\n3. **Circular**\n\n$$\n\\gamma(h) =\n\\begin{cases}\nc_0 + c \\left( \\frac{2}{\\pi} \\left[ \\arccos\\left(\\frac{h}{a}\\right) - \\frac{h}{a} \\sqrt{1 - \\left(\\frac{h}{a}\\right)^2} \\right] \\right), & 0 < h \\le a \\\\\nc_0 + c, & h > a \\\\\n0, & h = 0\n\\end{cases}\n$$\n\n4. **Gaussian**\n\n$$\n\\gamma(h) =\n\\begin{cases}\nc_0 + c \\left(1 - \\exp\\left(-\\frac{h^2}{a^2}\\right)\\right), & h > 0 \\\\\n0, & h = 0\n\\end{cases}\n$$\n\n5. **Linear**\n\n$$\n\\gamma(h) =\n\\begin{cases}\nc_0 + \\text{slope} \\cdot h, & h > 0 \\\\\n0, & h = 0\n\\end{cases}\n$$\n\n6. **Matern**\n\n$$\n\\gamma(h) =\n\\begin{cases}\nc_0 + c \\left( 1 - \\frac{1}{2^{\\nu-1} \\Gamma(\\nu)} \\left( \\frac{2 \\sqrt{\\nu} h}{a} \\right)^\\nu K_\\nu\\left( \\frac{2 \\sqrt{\\nu} h}{a} \\right) \\right), & h > 0 \\\\\n0, & h = 0\n\\end{cases}\n$$\n\nWhere:  \n\n- $c_0$ = nugget  \n- $c$ = partial sill  \n- $a$ = range  \n- $\\nu$ = Matern smoothness parameter  \n- $K_\\nu$ = modified Bessel function of the second kind\n\n\n\n\n\n::: {.cell fig-fullwidth='true'}\n::: {.cell-output-display}\n![](spatial_interpolate_files/figure-html/unnamed-chunk-14-1.png){width=960}\n:::\n:::\n\n\n\n\n\nIn R, this step is typically performed automatically to minimize the difference between the model function and the empirical scatter points.\n\n### Computing the Weights with the Lagrange Method\n\nUsing the fitted variogram and assuming **second-order stationarity** (constant mean and spatial dependence only on distance), the Kriging weights are obtained by solving the following system.\n\nThe following presents the mathematical formulation for determining the weights assigned to all observations when estimating the value at a target location.  \n\n1. Estimation Variance\n\nThe **estimation error** is defined as:\n\n$$\n\\epsilon = \\hat{Z}(x_0) - Z(x_0) = \\sum_{i=1}^{n} \\lambda_i Z(x_i) - Z(x_0)\n$$\n\nThe **Kriging variance**, i.e., the variance of the estimation error, is:\n\n$$\n\\sigma_K^2 = Var[\\epsilon] = Var\\left[\\sum_{i=1}^{n} \\lambda_i Z(x_i) - Z(x_0)\\right]\n$$\n\nUsing the semivariogram $\\gamma(h)$ fitted from all observations:\n\n$$\nVar(Z(x_i) - Z(x_j)) = 2\\gamma(x_i - x_j)\n$$\n\nwe can write the Kriging variance in terms of the weights:\n\n$$\n\\sigma_K^2 = \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\lambda_i \\lambda_j \\gamma(x_i - x_j) - 2 \\sum_{i=1}^{n} \\lambda_i \\gamma(x_i - x_0) + \\gamma(0)\n$$\n\nThis is a **quadratic function of the weights** $\\lambda_i$.\n\n2. Unbiasedness Constraint\n\nOrdinary Kriging assumes an **unknown but constant mean** $m$, so the estimator must be unbiased:\n\n$$\nE[\\hat{Z}(x_0) - Z(x_0)] = 0 \\quad \\Rightarrow \\quad \\sum_{i=1}^{n} \\lambda_i = 1\n$$\n\nThis is a **linear equality constraint**.\n\n3. Lagrange Multiplier Method\n\nTo minimize $\\sigma_K^2$ under the constraint $\\sum \\lambda_i = 1$, define the **Lagrangian function**:\n\n$$\nL(\\lambda_1, \\dots, \\lambda_n, \\mu) = \\sigma_K^2 + \\mu \\left( \\sum_{i=1}^{n} \\lambda_i - 1 \\right)\n$$\n\n- $\\mu$ is the **Lagrange multiplier**, enforcing the sum-of-weights constraint.\n\n4. Derivatives of the Lagrangian\n\nTake partial derivatives of $L$ with respect to each $\\lambda_i$ and $\\mu$:\n\n1. With respect to $\\lambda_i$:\n\n$$\n\\frac{\\partial L}{\\partial \\lambda_i} = \\frac{\\partial \\sigma_K^2}{\\partial \\lambda_i} + \\mu = 0\n$$\n\nCompute $\\partial \\sigma_K^2 / \\partial \\lambda_i$:\n\n$$\n\\frac{\\partial \\sigma_K^2}{\\partial \\lambda_i} = 2 \\sum_{j=1}^{n} \\lambda_j \\gamma(x_i - x_j) - 2 \\gamma(x_i - x_0)\n$$\n\nDivide by 2 and redefine $\\mu' = \\mu/2$:\n\n$$\n\\sum_{j=1}^{n} \\lambda_j \\gamma(x_i - x_j) + \\mu' = \\gamma(x_i - x_0)\n$$\n\n2. With respect to $\\mu$:\n\n$$\n\\frac{\\partial L}{\\partial \\mu} = \\sum_{i=1}^{n} \\lambda_i - 1 = 0\n$$\n\nThis ensures **unbiasedness**.\n\n5. Matrix Form\n\nCombine all $n$ equations for $\\lambda_i$ with the constraint for $\\mu$:\n\n$$\n\\begin{bmatrix}\n\\gamma(x_1-x_1) & \\cdots & \\gamma(x_1-x_n) & 1 \\\\\n\\vdots & \\ddots & \\vdots & \\vdots \\\\\n\\gamma(x_n-x_1) & \\cdots & \\gamma(x_n-x_n) & 1 \\\\\n1 & \\cdots & 1 & 0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\lambda_1 \\\\ \\vdots \\\\ \\lambda_n \\\\ \\mu\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\gamma(x_1-x_0) \\\\ \\vdots \\\\ \\gamma(x_n-x_0) \\\\ 1\n\\end{bmatrix}\n$$\n\n- The top-left $n \\times n$ block contains **semivariances between observed points**.  \n- The last row and column enforce **$\\sum \\lambda_i = 1$**.  \n- The right-hand side contains **semivariances between each observation and the target point**.\n\n\nOnce the weights for all observations are determined, the estimation process proceeds similarly to IDW interpolation. However, in R, a more efficient workflow is available using the `gstat` and `terra` packages, which will be demonstrated in the next chapter.\n\n# Spatial Interpolation in R\n\nSpatial interpolation is a fundamental technique in geostatistics and environmental sciences, used to estimate values of a variable at unsampled locations based on observations at known points. In R, this can be efficiently performed using the **`gstat`** and **`terra`** packages. The typical workflow involves two main steps:\n\n1. **Definition of the interpolation model**: specifying the method and its associated parameters via the `gstat()` function.\n2. **Prediction at unmeasured locations**: applying the defined model to a spatial grid using the `interpolate()` function from `terra`.\n\nThis workflow supports several widely used interpolation methods, including **nearest neighbor**, **inverse distance weighting (IDW)**, and **ordinary kriging**.\n\n\n## Basic Workflow\n\n\n### Defining the Interpolation Model with `gstat()`\n\nThe `gstat()` function provides a unified framework for specifying interpolation models. It allows the user to define the variable to be interpolated, the spatial coordinates, and method-specific parameters controlling interpolation behavior.\n\n**General Syntax**\n\n```r\n#| eval: false\nmodel_Interpolate <- gstat(\n  formula   = variable ~ 1,\n  locations = ~x + y,\n  data      = df_Data,\n  nmax      = 10,\n  set       = list(idp = 2)\n)\n```\n\n**Key Arguments**\n\n- `formula = variable ~ 1`\n  Specifies the target variable for interpolation. The right-hand side `1` indicates that only a constant mean is assumed, i.e., no trend or covariates are considered.\n\n  - Example: `precip ~ 1` for ordinary kriging or IDW.\n  - If predictors are included, e.g., `precip ~ elevation`, the model becomes **universal kriging**.\n\n- `locations = ~x + y`\n  Defines the coordinate columns in the dataset.\n\n- `data = df_Data`\n  The input dataset, which may be a dataframe or a spatial object such as `SpatVector`, `sf`, or `SpatialPointsDataFrame`.\n\n- Neighbor selection parameters (`nmax`, `nmin`, `maxdist`)\n  Control the spatial neighborhood used for interpolation.\n\n  - `nmax`: maximum number of neighbors considered.\n  - `nmin`: minimum number of neighbors required for prediction.\n  - `maxdist`: maximum search distance; points beyond this threshold are ignored.\n    These parameters influence both the smoothness of the interpolated surface and computational efficiency.\n\n-`set = list()`\n  Method-specific parameters.\n\n  - For **IDW**, `set = list(idp = p)` defines the power parameter $p$.\n\n    - `idp = 0`: equal weighting for all neighbors.\n    - `idp > 1`: higher weight for closer points; larger $p$ → more localized influence.\n  - For **nearest neighbor**, set `nmax = 1`.\n  - For **kriging**, variogram parameters are specified using the `model` argument.\n\n- `model`\n  Required for **kriging** methods; specifies the fitted variogram model, typically generated with `variogram()` and `fit.variogram()`.\n\n| Method             | Key Parameters                | Description                                                       |\n| ------------------ | ----------------------------- | ----------------------------------------------------------------- |\n| Nearest Neighbor   | `nmax = 1`                    | Assigns the value of the closest observed point                   |\n| k-Nearest Neighbor | `nmax = k`                    | Uses the mean of the k nearest observations                       |\n| IDW                | `set = list(idp = p)`         | Power parameter $p$ controls weight decay with distance           |\n| Ordinary Kriging   | `model = v_model` (variogram) | Accounts for spatial correlation and provides estimation variance |\n\nIn summary, `gstat()` acts as the central function for constructing spatial interpolation models. The choice of `formula`, neighbor parameters (`nmax`, `nmin`), and method-specific arguments (`set` or `model`) determines the behavior of the interpolation method.\n\n\n\n### Applying the Interpolation Model with `interpolate()`\n\nAfter defining the model, the `interpolate()` function from the **terra** package is used to estimate values at unsampled locations, typically on a raster grid.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrst_Interpolate <- interpolate(\n  rst_Template,\n  model_Vario,\n  debug.level = 0\n)\n```\n:::\n\n\n\n\nMain Parameters\n\n-`raster_template`: A `SpatRaster` object defining the spatial extent, resolution, and coordinate reference system for the interpolated output.\n-`model`: The interpolation model object created via `gstat()`.\n-`debug.level`: Controls the verbosity of output messages; commonly set to `0` (silent) or `1` (minimal information).\n\nThe function returns a raster object containing predicted values at each grid cell, allowing for subsequent visualization and analysis.\n\n\nBy combining `gstat()` and `interpolate()`, R provides a flexible and robust framework for spatial prediction, enabling the creation of continuous surfaces from point measurements. This approach is widely applicable in hydrology, meteorology, ecology, and other spatially explicit fields.\n\n### Example Dataset\n\nFor demonstration purposes, we consider the average precipitation (1981–2010) recorded at 50 meteorological stations in North Rhine-Westphalia (NRW). The dataset comprises the coordinates of each station and the corresponding mean precipitation values. This dataset will be used to illustrate spatial interpolation methods.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nggplot() +\n  geom_spatvector(data = vct_Station_NRW_S50, aes(fill = NiederschlagJahr),\n                  shape = 24, size = 4) +\n  geom_spatvector(data = vct_Boundry_NRW, color = color_TUD_pink, fill = NA) +\n  scale_fill_gradientn(\"Value\", \n                       colors = color_DRESDEN, \n                       na.value = \"transparent\",\n                       limits = c(550, 1500)) +\n  ggtitle('Mean Annual Precipitation (1981–2010)') +\n  coord_sf(expand = FALSE) +\n  theme(axis.title = element_blank(),\n        axis.text.y = element_text(angle = 90, hjust = .5))\n```\n\n::: {.cell-output-display}\n![](spatial_interpolate_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\n\n\nIn order to perform the interpolation, it is necessary to define a **template raster**, which specifies the locations where predictions should be made. The template raster allows the user to control the **spatial resolution** and the **extent** of the interpolation, ensuring that the resulting surface matches the desired research area and level of detail.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrst_Template_NRW <- rast(vct_Boundry_NRW, res = 0.01) \nvalues(rst_Template_NRW) <- 1\nrst_Template_NRW <-  mask(rst_Template_NRW, vct_Boundry_NRW)\n\n# Convert station SpatVector to a data.frame with coordinates\ndf_Station_NRW_S50 <- data.frame(geom(vct_Station_NRW_S50)[, c(\"x\", \"y\")],\n                                 as.data.frame(vct_Station_NRW_S50))\n```\n:::\n\n\n\n\n\n\n## Nearest Neighbor (1-Nearest) and Thiessen Polygons\n\n\nThe nearest neighbor method is closely related to **Thiessen polygons** (also called **Voronoi diagrams**). In this approach, the study area is partitioned into polygons, each surrounding a single observation point. All locations within a polygon are assumed to have the same value as the observation at its center.\n\n\n\n### Nearest Neighbor (1-Nearest)\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_Near1 <- gstat(\n  formula = NiederschlagJahr ~ 1,\n  locations = ~x + y,\n  data = df_Station_NRW_S50,\n  nmax = 1,\n  set = list(idp = 0)\n)\n\n# Interpolate on raster grid\nrst_Near1 <- interpolate(rst_Template_NRW, model_Near1, debug.level = 0) |> \n  mask(vct_Boundry_NRW)\n```\n:::\n\n\n\n\n### Thiessen Polygons\n\nThiessen polygons provide a geometric framework for nearest neighbor interpolation, particularly useful when measurement points are sparse, and smooth spatial gradients cannot be assumed.\n\nThe construction procedure is as follows:\n\n1. **Triangulation**: Connect all observation points to form a Triangulated Irregular Network (TIN) that satisfies the **Delaunay criterion**.\n2. **Perpendicular Bisectors**: Draw perpendicular bisectors for each triangle edge. The intersections of these bisectors define the vertices of the Thiessen polygons.\n3. **Anchor Points**: Each polygon contains exactly one observation point (the anchor), and all locations within the polygon are closer to this anchor than to any other observation.\n\nThe resulting Thiessen polygons effectively assign each unsampled location to the nearest observation, creating a spatial partitioning consistent with the 1-nearest neighbor principle.\n\n![Illustration of Thiessen polygon](../images/ThiessenSteps.png)\n\nIn R, Thiessen polygons are implemented as **Voronoi polygons** using the `voronoi()` function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvct_Voronoi_NRW_S50 <- voronoi(vct_Station_NRW_S50) |> crop(vct_Boundry_NRW)\n```\n:::\n\n\n\n\nThis function generates the polygonal tessellation corresponding to the nearest neighbor regions of the input points.\n\n\n\n\n### Comparison of Results\n\nThe following plots illustrate the outcomes of **1-nearest neighbor interpolation** and **Thiessen polygons** applied to the same dataset.  \n\nAs expected, both methods produce almost same results because Thiessen polygons are a geometric representation of the 1-nearest neighbor principle. Each unsampled location is assigned the value of the closest observation point in both approaches.  \n\nVisually, there is no obvious difference between the two methods; both generate a piecewise-constant surface with abrupt changes at the boundaries between regions influenced by different observation points.\n\n*Key observations:*\n\n* Both surfaces preserve the exact values of the original observations.  \n* Discontinuities occur along polygon edges or nearest-neighbor boundaries.  \n\n\n\n\n::: {.cell fig-fullwidth='true'}\n\n```{.r .cell-code  code-fold=\"true\"}\ngp_Near1 <- ggplot() +\n  geom_spatraster(data = rst_Near1, aes(fill = var1.pred)) +\n  geom_spatvector(data = vct_Boundry_NRW, color = color_TUD_pink, fill = NA) +\n  scale_fill_gradientn(\"Value\", \n                       colors = color_DRESDEN, \n                       na.value = \"transparent\",\n                       limits = c(550, 1500)) +\n  ggtitle('Nearest Neighbor (1-nearest)') +\n  coord_sf(expand = FALSE) +\n  theme(axis.title = element_blank(),\n        axis.text.y = element_text(angle = 90, hjust = .5),\n    legend.position = \"inside\",\n    legend.position.inside = c(0.99, 0.01),\n    legend.justification = c(\"right\", \"bottom\"),\n    legend.direction = \"horizontal\",\n    legend.title.position = \"top\"\n  ) +\n  guides(\n    fill = guide_colorbar(\n      barwidth = 8,\n      barheight = 0.6\n    )\n  )\ngp_Voronoi_NRW_S50 <- ggplot() +\n  geom_spatvector(data = vct_Voronoi_NRW_S50, aes(fill = NiederschlagJahr)) +\n  geom_spatvector(data = vct_Boundry_NRW, color = color_TUD_pink, fill = NA) +\n  scale_fill_gradientn(\"Value\", \n                       colors = color_DRESDEN, \n                       na.value = \"transparent\",\n                       limits = c(550, 1500)) +\n  ggtitle('Thiessen Polygons') +\n  coord_sf(expand = FALSE) +\n  theme(axis.title = element_blank(),\n        axis.text.y = element_text(angle = 90, hjust = .5),\n    legend.position = \"inside\",\n    legend.position.inside = c(0.99, 0.01),\n    legend.justification = c(\"right\", \"bottom\"),\n    legend.direction = \"horizontal\",\n    legend.title.position = \"top\"\n  ) +\n  guides(\n    fill = guide_colorbar(\n      barwidth = 8,\n      barheight = 0.6\n    )\n  )\n\n(gp_Near1 | gp_Voronoi_NRW_S50)\n```\n\n::: {.cell-output-display}\n![](spatial_interpolate_files/figure-html/unnamed-chunk-20-1.png){width=1152}\n:::\n:::\n\n\n\n\n\n## k-Nearest Neighbors (k-NN)\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_Near5 <- gstat(\n  formula = NiederschlagJahr ~ 1,\n  locations = ~x + y,\n  data = df_Station_NRW_S50,\n  nmax = 5,\n  set = list(idp = 0)\n)\n\n# Interpolate on raster grid\nrst_Near5 <- interpolate(rst_Template_NRW, model_Near5, debug.level = 0) |> \n  mask(vct_Boundry_NRW)\n```\n:::\n\n\n\n\n\nCompared to the 1-nearest method, the k-nearest approach still exhibits noticeable block-like boundaries. However, the resulting surface is already smoother, as each block incorporates information from multiple observation points rather than relying on a single nearest station. A remaining drawback is that, at some observation locations, the interpolated value may differ from the original measured value, leading to local inconsistencies.\n\n\n\n\n::: {.cell fig-fullwidth='true'}\n\n```{.r .cell-code  code-fold=\"true\"}\ngp_Near5 <- ggplot() +\n  geom_spatraster(data = rst_Near5, aes(fill = var1.pred)) +\n  geom_spatvector(data = vct_Boundry_NRW, color = color_TUD_pink, fill = NA) +\n  geom_spatvector(data = vct_Station_NRW_S50, aes(fill = NiederschlagJahr),\n                  shape = 24, size = 3, color = \"grey96\", linewidth = 1) +\n  scale_fill_gradientn(\"Value\", \n                       colors = color_DRESDEN, \n                       na.value = \"transparent\",\n                       limits = c(550, 1500)) +\n  ggtitle('k-Nearest Neighbors') +\n  coord_sf(expand = FALSE) +\n  theme(axis.title = element_blank(),\n        axis.text.y = element_text(angle = 90, hjust = .5),\n    legend.position = \"inside\",\n    legend.position.inside = c(0.99, 0.01),\n    legend.justification = c(\"right\", \"bottom\"),\n    legend.direction = \"horizontal\",\n    legend.title.position = \"top\"\n  ) +\n  guides(\n    fill = guide_colorbar(\n      barwidth = 8,\n      barheight = 0.6\n    )\n  )\n\n(gp_Near1 | gp_Near5)\n```\n\n::: {.cell-output-display}\n![](spatial_interpolate_files/figure-html/unnamed-chunk-22-1.png){width=1152}\n:::\n:::\n\n\n\n\n\n## Inverse Distance Weighting (IDW)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_IDW <- gstat(\n  formula = NiederschlagJahr ~ 1,\n  locations = ~x + y,\n  data = df_Station_NRW_S50,\n  nmax = 5\n)\nrst_IDW <- interpolate(rst_Template_NRW, model_IDW, debug.level = 0) |> \n  mask(vct_Boundry_NRW)\n```\n:::\n\n\n\n\nCompared to the k-nearest-neighbor method, the **IDW** approach exhibits only very subtle block-like boundaries. Within each block, the values already vary smoothly due to the distance-based weighting. Overall, the interpolated surface produced by IDW appears much smoother, as the influence of each observation point gradually decreases with distance, resulting in a more continuous spatial pattern. The phenomenon in which values appear mismatched or inconsistent within local regions has largely disappeared.\n\n\n\n\n\n\n\n\n::: {.cell fig-fullwidth='true'}\n\n```{.r .cell-code  code-fold=\"true\"}\ngp_IDW <- ggplot() +\n  geom_spatraster(data = rst_IDW, aes(fill = var1.pred)) +\n  geom_spatvector(data = vct_Boundry_NRW, color = color_TUD_pink, fill = NA) +\n  scale_fill_gradientn(\"Value\", \n                       colors = color_DRESDEN, \n                       na.value = \"transparent\",\n                       limits = c(550, 1500)) +\n  ggtitle('Inverse Distance Weighting (IDW)') +\n  coord_sf(expand = FALSE) +\n  theme(axis.title = element_blank(),\n        axis.text.y = element_text(angle = 90, hjust = .5),\n    legend.position = \"inside\",\n    legend.position.inside = c(0.99, 0.01),\n    legend.justification = c(\"right\", \"bottom\"),\n    legend.direction = \"horizontal\",\n    legend.title.position = \"top\"\n  ) +\n  guides(\n    fill = guide_colorbar(\n      barwidth = 8,\n      barheight = 0.6\n    )\n  )\n\n(gp_Near5 | gp_IDW)\n```\n\n::: {.cell-output-display}\n![](spatial_interpolate_files/figure-html/unnamed-chunk-24-1.png){width=1152}\n:::\n:::\n\n\n\n\n\n### Comparison of $k$ and $p$ in Interpolation\n\nThe following figure illustrates how the **number of neighbors $k$** and the **IDW power parameter $p$** influence the interpolation results.\n\n* **Effect of $k$ (number of nearest neighbors)**\n  - Increasing $k$ includes more observation points in the interpolation.\n  - The resulting surface becomes **smoother** and less influenced by single extreme values.\n  - Polygon-like discontinuities seen in 1-nearest neighbor or small $k$ cases are reduced.\n\n* **Effect of $p$ (IDW power parameter)**\n  - Controls the weighting of neighbors based on distance.\n  - Larger $p$ values assign **more weight to nearby or extreme values**, producing areas dominated by high or low observations.\n  - Small $p$ values distribute influence more evenly, creating a smoother surface similar to simple averaging.\n\nIn summary:\n\n| Parameter | Effect on Interpolation                                      |\n|-----------|--------------------------------------------------------------|\n| $k$         | Larger $k$ → more neighbors considered → smoother surface, less polygonal artifacts |\n| $p$         | Larger $p$ → stronger influence of nearby/extreme points → more pronounced peaks and valleys |\n\nThis demonstrates the trade-off between smoothing and sensitivity to local extremes when choosing $k$ and $p$ for k-NN or IDW interpolation.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define combinations of neighbors (nmax) and power (idp)\nlst_IDW_Params <- list(\n  k5p1  = list(nmax = 5, idp = 1),\n  k10p1 = list(nmax = 10, idp = 1),\n  k5p3  = list(nmax = 5, idp = 3),\n  k10p3 = list(nmax = 10, idp = 3)\n)\n\n# Function to create IDW raster\ncreate_idw <- function(nmax, idp) {\n  model <- gstat(\n    formula = NiederschlagJahr ~ 1,\n    locations = ~x + y,\n    data = df_Station_NRW_S50,\n    nmax = nmax,\n    set = list(idp = idp)\n  )\n  interpolate(rst_Template_NRW, model, debug.level = 0) |> mask(vct_Boundry_NRW)\n}\n\n\n\n# Generate all four rasters\nlst_rst_IDW <- lapply(lst_IDW_Params, \\(p) create_idw(p$nmax, p$idp))\n```\n:::\n\n::: {.cell fig-fullwidth='true'}\n\n```{.r .cell-code  code-fold=\"true\"}\nrst_IDW_combined <- rast(lst_rst_IDW)\nrst_IDW_combined <- rst_IDW_combined[[c(1, 3, 5, 7)]]\n# Set layer names to match parameter combinations\nnames(rst_IDW_combined) <- c(\"k=5, p=1\", \"k=10, p=1\", \"k=5, p=3\", \"k=10, p=3\")\n\n# Create facet plot\nggplot() +\n  geom_spatraster(data = rst_IDW_combined) +\n  geom_spatvector(data = vct_Boundry_NRW, color = color_TUD_pink, fill = NA) +\n  facet_wrap(~lyr, ncol = 2) +\n  scale_fill_gradientn(\"Value\", \n                       colors = color_DRESDEN, \n                       na.value = \"transparent\",\n                       limits = c(550, 1500)) +\n  coord_sf(expand = FALSE) +\n  labs(title = \"Inverse Distance Weighting (IDW) - Parameter Comparison\") +\n  theme(\n    axis.title = element_blank(),\n    axis.text.y = element_text(angle = 90, hjust = 0.5),\n    legend.position = \"inside\",\n    legend.position.inside = c(0.99, 0.01),\n    legend.justification = c(\"right\", \"bottom\"),\n    legend.direction = \"horizontal\",\n    legend.title.position = \"top\",\n    strip.text = element_text(size = 10, face = \"bold\")\n  ) +\n  guides(\n    fill = guide_colorbar(\n      barwidth = 8,\n      barheight = 0.6\n    )\n  )\n```\n\n::: {.cell-output-display}\n![](spatial_interpolate_files/figure-html/unnamed-chunk-26-1.png){width=1152}\n:::\n:::\n\n\n\n\n\n\n## Ordinary Kriging\n\n\n\n### Fitting a Variogram and Selecting a Model\n\nThe variogram is a key tool in kriging, representing the relationship between **semivariance** and distance. In R, this process involves three main steps:\n\n1. **Define the kriging model** with `gstat()`\n   - Set the variable to interpolate (`formula = variable ~ 1`), indicating an assumed constant mean.\n   - Specify the spatial coordinates (`locations = ~x + y`).\n   - Provide the observed data (`data = df_Data`).\n\n2. **Compute the experimental variogram** with `variogram()`\n   - Group semivariance values by distance to create a scatter plot of spatial dependence.\n   - Use the argument `width` to set the distance bin size (e.g., `width = 0.05`), which controls how semivariance is averaged across distance intervals.\n\n3. **Fit a theoretical variogram** with `fit.variogram()`\n   - Fit standard variogram functions (spherical, exponential, Gaussian, etc.) to the experimental variogram.\n   - The chosen model provides the parameters required for ordinary kriging, such as the sill, range, and nugget.\n\n\nThe variogram fitting process requires plausible initial estimates for the following parameters, as they guide the optimization toward a meaningful solution. These initial values can typically be inferred from the empirical variogram scatter plot.\n\n- **psill (partial sill)**: Represents the portion of the total variance that is spatially structured. It corresponds to the difference between the sill and the nugget and determines the overall height of the variogram curve (excluding measurement error or microscale variability).\n\n- **range**: Defines the distance at which spatial correlation becomes negligible. Beyond this distance, observations no longer influence each other, and the variogram reaches its sill. The range therefore indicates the spatial extent of dependence in the data.\n\n- **nugget**: Captures the variance at infinitesimally small distances. It reflects measurement error, microscale variability, or unresolved spatial heterogeneity. A non-zero nugget results in a jump of the variogram at the origin.\n\nProviding reasonable initial values for these parameters is crucial, as they ensure stable and accurate variogram fitting during model optimization.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_Vario <- gstat(\n  formula = NiederschlagJahr ~ 1,\n  locations = ~x + y,\n  data = df_Station_NRW_S50\n)\n\nvario_S50 <- variogram(model_Vario, width = 0.05)\n\nname_VarioModel <- c(\"Exp\", \"Sph\", \"Cir\", \"Gau\", \"Lin\", \"Mat\")\nnames(name_VarioModel) <- name_VarioModel\n\n\npsill  <- 6e4\nrange  <- 0.5\nnugget <- 3e3\nlst_FitVario <- map(name_VarioModel[-6], \\(m_Vario) fit.variogram(vario_S50, vgm(psill, m_Vario, range, nugget)))\nlst_FitVario$Mat <- fit.variogram(vario_S50, vgm(psill, \"Mat\", range, nugget, kappa=.9))\n```\n:::\n\n\n\n\n\n### Comparison of Variogram Models\n\nIn the figure below, six theoretical variogram models are fitted to the same dataset:\n\n* At **short distances**, all models show a similar increasing trend in semivariance, reflecting strong local correlation.\n* At **larger distances**, the models diverge:\n  - Some flatten earlier, indicating limited long-range correlation.\n  - Others increase more gradually, suggesting extended spatial dependence.\n\nThis illustrates that the selection of variogram model and the associated parameters (sill, range, nugget) is critical in ordinary kriging, as it directly affects how observations are weighted and the resulting spatial interpolation pattern.\n\n\n\n\n\n::: {.cell fig-fullwidth='true'}\n\n```{.r .cell-code  code-fold=\"true\"}\nlst_df_VarioLine <- map(lst_FitVario, variogramLine, maxdist = max(vario_S50$dist))\ndf_VarioLine_All <- do.call(rbind, lst_df_VarioLine)\ndf_VarioLine_All$model <- rep(c(\"Exponential\", \"Spherical\", \"Circular\", \"Gaussian\", \"Linear\", \"Matern\"), each = 200)\n\n# Create color palette for models\nmodel_colors <- c(\n  \"Exponential\" = color_TUD_orange,\n  \"Spherical\" = color_RUB_blue,\n  \"Circular\" = color_TUD_lightblue,\n  \"Gaussian\" = color_RUB_green, \n  \"Linear\" = color_TUD_pink,\n  \"Matern\" = color_TUD_redpurple\n)\n\n# Determine the y-axis range from your data\ny_range <- range(vario_S50$gamma, df_VarioLine_All$gamma, na.rm = TRUE)\n\ngp_Fit <- ggplot() +\n  geom_point(data = vario_S50, aes(x = dist, y = gamma), size = 3, shape = 1, color = color_RUB_blue) +\n  geom_line(data = df_VarioLine_All, aes(x = dist, y = gamma, color = model), linewidth = 1) +\n  scale_color_manual(\"Model\", values = model_colors) +\n  labs(x = \"Distance (°)\", y = NULL) +  # Remove y-axis title\n  lims(y = y_range) +  # Same y-axis range\n  theme(\n    axis.text.y = element_blank(),  # Remove y-axis text\n    axis.ticks.y = element_blank(), # Remove y-axis ticks\n    legend.position = \"inside\",\n    legend.justification = c(\"right\", \"bottom\"),\n    legend.position.inside = c(0.99, 0.01)\n  )\n\n\n\ngp_Scatter <- ggplot() +\n  geom_point(data = vario_S50, aes(x = dist, y = gamma, color = dist), size = 3) +\n  scale_color_gradientn(\"Distance h (°)\", colors = color_DRESDEN) +\n  labs(x = \"Distance (°)\", y = \"Semivariance\") +\n  lims(y = y_range) +\n  theme(\n    axis.text.y = element_text(angle = 90, hjust = .5),\n    legend.position = \"inside\",\n    legend.position.inside = c(0.99, 0.01),\n    legend.justification = c(\"right\", \"bottom\"),\n    legend.direction = \"horizontal\",\n    legend.title.position = \"top\"\n  ) +\n  guides(\n    color = guide_colorbar(barwidth = 8, barheight = 0.6)\n  )\n\n\n# Combine the plots\n(gp_Scatter | gp_Fit) +\n  plot_annotation(title = \"Variogram Models Comparison\")\n```\n\n::: {.cell-output-display}\n![](spatial_interpolate_files/figure-html/unnamed-chunk-28-1.png){width=1152}\n:::\n:::\n\n\n\n\n\n### Cross-Validation and Method Selection\n\nTo select the most appropriate interpolation method, **cross-validation** can be performed using the observed data. This approach evaluates how well each method predicts known values by temporarily withholding each observation and comparing the predicted value to the actual measurement.\n\nThe following table summarizes the **root mean square error (RMSE)** for six variogram-based kriging models:\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlst_RMSE_VarioFit <- map(lst_FitVario, \\(m_Fit) {\n  cv_model <-  krige.cv(NiederschlagJahr ~ 1, locations = ~x + y, data = df_Station, model = m_Fit)\n  obs <- cv_model$observed\n  pred <- cv_model$var1.pred\n  sqrt(mean((obs - pred)^2, na.rm = TRUE))\n})\n\n\nprint(lst_RMSE_VarioFit |> unlist())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Exp      Sph      Cir      Gau      Lin      Mat \n93.15135 87.70613 90.56338 96.44990 94.64919 92.29901 \n```\n\n\n:::\n:::\n\n\n\n\n\nFrom this comparison, the **spherical (`Sph`) model** exhibits the lowest RMSE, indicating the best predictive performance for the dataset. Consequently, the spherical variogram will be used in subsequent analyses.\n\n### Results of Ordinary Kriging Compared to IDW\n\nThe figure below presents the interpolation results obtained with **ordinary kriging (OK)** and **inverse distance weighting (IDW)** for the same dataset.\n\nThere is no significant difference between the two methods in overall pattern. Ordinary kriging produces a **slightly smoother surface**, reducing abrupt changes observed in IDW or nearest neighbor methods. OK is **less influenced by local extreme values**, thanks to its use of spatial correlation weights derived from the variogram.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_OK <- gstat(\n  formula = NiederschlagJahr ~ 1,\n  locations = ~x + y,\n  data = df_Station,\n  model = lst_FitVario$Sph,\n  nmax = 5\n)\n\nrst_OK <- interpolate(rst_Template_NRW, model_OK, debug.level = 0) |> \n  mask(vct_Boundry_NRW)\n```\n:::\n\n::: {.cell fig-fullwidth='true'}\n\n```{.r .cell-code  code-fold=\"true\"}\ngp_OK <- ggplot() +\n  geom_spatraster(data = rst_OK, aes(fill = var1.pred)) +\n  geom_spatvector(data = vct_Boundry_NRW, color = color_TUD_pink, fill = NA) +\n  geom_spatvector(data = vct_Station_NRW_S50, aes(fill = NiederschlagJahr),\n                  shape = 24, size = 3, color = \"grey96\", linewidth = 1) +\n  scale_fill_gradientn(\"Value\", \n                       colors = color_DRESDEN, \n                       na.value = \"transparent\",\n                       limits = c(550, 1500)) +\n  ggtitle('Ordinary Kriging with Spherical Variogramm') +\n  coord_sf(expand = FALSE) +\n  theme(axis.title = element_blank(),\n        axis.text.y = element_text(angle = 90, hjust = .5),\n    legend.position = \"inside\",\n    legend.position.inside = c(0.99, 0.01),\n    legend.justification = c(\"right\", \"bottom\"),\n    legend.direction = \"horizontal\",\n    legend.title.position = \"top\"\n  ) +\n  guides(\n    fill = guide_colorbar(\n      barwidth = 8,\n      barheight = 0.6\n    )\n  )\n\n(gp_IDW | gp_OK)\n```\n\n::: {.cell-output-display}\n![](spatial_interpolate_files/figure-html/unnamed-chunk-31-1.png){width=1152}\n:::\n:::\n\n\n\n\n### Effect of Variogram Model Choice\n\nThe subsequent figure shows the results for four different variogram models applied in OK:\n\n* At **short distances**, all models behave similarly, consistent with the fitted experimental variogram.\n* Differences at **larger distances** have a **minimal effect** on the interpolated surface.\n* Overall, the choice of variogram model slightly influences long-range patterns but does not substantially change the final interpolation results.\n\nThis demonstrates that, for this dataset, ordinary kriging is robust to the selection of standard variogram models, and the key influence on the interpolation comes from the short-range spatial correlation captured in the variogram.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlst_rst_OK_VarioModel <- map(lst_FitVario, \\(m_OK) {\n  model_OK <- gstat(\n  formula = NiederschlagJahr ~ 1,\n  locations = ~x + y,\n  data = df_Station,\n  model = lst_FitVario$Sph\n)\n\ninterpolate(rst_Template_NRW, model_OK, debug.level = 0) |> \n  mask(vct_Boundry_NRW)\n\n})\n```\n:::\n\n::: {.cell fig-fullwidth='true'}\n\n```{.r .cell-code  code-fold=\"true\"}\nrst_OK_combined <- rast(lst_rst_OK_VarioModel)\nrst_OK_combined <- rst_OK_combined[[c(1, 3, 5, 7, 9, 11)]]\n# Set layer names to match parameter combinations\nnames(rst_OK_combined) <- names(lst_rst_OK_VarioModel)\n\n# Create facet plot\nggplot() +\n  geom_spatraster(data = rst_OK_combined[[1:4]]) +\n  geom_spatvector(data = vct_Boundry_NRW, color = color_TUD_pink, fill = NA) +\n  facet_wrap(~lyr, ncol = 2) +\n  scale_fill_gradientn(\"Value\", \n                       colors = color_DRESDEN, \n                       na.value = \"transparent\",\n                       limits = c(550, 1500)) +\n  coord_sf(expand = FALSE) +\n  labs(title = \"Ordinary Kriging (OK) - Variogram Comparison\") +\n  theme(\n    axis.title = element_blank(),\n    axis.text.y = element_text(angle = 90, hjust = 0.5),\n    legend.position = \"inside\",\n    legend.position.inside = c(0.99, 0.01),\n    legend.justification = c(\"right\", \"bottom\"),\n    legend.direction = \"horizontal\",\n    legend.title.position = \"top\",\n    strip.text = element_text(size = 10, face = \"bold\")\n  ) +\n  guides(\n    fill = guide_colorbar(\n      barwidth = 8,\n      barheight = 0.6\n    )\n  )\n```\n\n::: {.cell-output-display}\n![](spatial_interpolate_files/figure-html/unnamed-chunk-33-1.png){width=1152}\n:::\n:::\n",
    "supporting": [
      "spatial_interpolate_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}