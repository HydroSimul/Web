{
  "hash": "f6b9c7f885cb9c3713da7480f6d99832",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Basic Processing\"\nexecute:\n  warning: false\n  error: false\nsidebar:\n  contents: auto\nnumber-sections: true\n---\n\n\n\n\nIn this article, we will cover fundamental techniques for manipulating and analyzing time series data. This includes tasks such as creating time series, summarizing data based on time indices, identifying trends, and more.\n\nTime series data often comes with specific considerations related to time zones, varying numbers of days in months, and leap years. \n\n1. **Time Zones:** Time series data collected from different regions or sources may be recorded in various time zones. Converting data to a consistent time zone is crucial to ensure accurate analysis and visualization, especially for data with hourly resolution.\n\n2. **Varying Days in Months:** Some months have 30 days, while others have 31, and February can have 28 or 29 days in leap years. This variation should be considered when performing calculations based on monthly or daily data.\n\n3. **Leap Years:** Leap years, which occur every four years, add an extra day (February 29) to the calendar. Analysts need to account for leap years when working with annual time series data to avoid inconsistencies.\n\nProperly accounting for these specifics is crucial for accurate analysis and interpretation of time series data.\n\n\n# Library\n\n\nTime series data structures are not standard in R, but the `xts` package is commonly used to work with time indices. However, it's important to note that for processes that don't rely on specific time indexing, the original data structure is sufficient. Time series structures are particularly useful when you need to perform time-based operations and analysis.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(xts)\nlibrary(tidyverse)\n```\n:::\n\n\n\n\n\n# Example Files\n\nThe example files provided consist of three discharge time series for the Ruhr River in the Rhein basin, Germany. These data sets are sourced from open data available at [ELWAS-WEB NRW](https://www.elwasweb.nrw.de/elwas-web/index.xhtml). You can also access it directly from the internet via [Github](https://raw.githubusercontent.com/HydroSimul/Web/main/data_share).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfn_Bachum <- \"https://raw.githubusercontent.com/HydroSimul/Web/main/data_share/Bachum_2763190000100.csv\"\nfn_Oeventrop <- \"https://raw.githubusercontent.com/HydroSimul/Web/main/data_share/Oeventrop_2761759000100.csv\"\nfn_Villigst <- \"https://raw.githubusercontent.com/HydroSimul/Web/main/data_share/Villigst_2765590000100.csv\"\n```\n:::\n\n\n\n\n\n# Create data\n\n\nBefore creating a time series structure, the data should be loaded into R. Time series in R can typically (only) support two-dimensional data structures, such as matrices and data frames. \n\nIf the date-time information is not correctly recognized during reading or if there is no time data present, you need to make sure that you have a valid time index. \n\nThere are two primary ways to create a time series in R:\n\n- `xts()`: With this method, you explicitly specify the time index and create a time series object. This is useful when you have a matrix with an external time index.\n\n- `as.xts()`: This method is more straightforward and is suitable when you have a data frame with a date column. The function will automatically recognize the date column and create a time series.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read a CSV file as data.frame\ndf_Bachum <- read_csv2(fn_Bachum, skip = 10, col_names = FALSE)\ndf_Villigst <- read_csv2(fn_Villigst, skip = 10, col_names = FALSE)\n\n# Convert Date column to a Date type\ndf_Bachum$X1 <- as_date(df_Bachum$X1, format = \"%d.%m.%Y\")\ndf_Villigst$X1 <- as_date(df_Villigst$X1, format = \"%d.%m.%Y\")\n\n# Create an xts object\nxts_Bachum <- xts(df_Bachum$X2, order.by = df_Bachum$X1)\nxts_Villigst <- as.xts(df_Villigst)\n```\n:::\n\n\n\n\n\n# Merging Several Time Series\n\nIn R, the time index is consistent and follows a standardized format. This consistency in time indexing makes it easy to combine multiple time series into a single dataset based on their time index.\n\n- `merge()`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxts_Rhur <- merge(xts_Bachum, xts_Villigst)\nnames(xts_Rhur) <- c(\"Bachum\", \"Villigst\")\n```\n:::\n\n\n\n\nIt's worth noting that when working with time series data in R, the length of the time series doesn't necessarily have to be the same for all time series. This flexibility allows you to work with data that may have missing or varying data points over time, which is common in many real-world scenarios. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(xts_Bachum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12053\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(xts_Villigst)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11499\n```\n\n\n:::\n:::\n\n\n\n\n# Subsetting (Index with time)\n\nYou can work with time series data in R using both integer indexing, and time-based indexing using time intervals.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a time sequence\nts_Inteval <- seq(as_date(\"1996-01-01\"), as_date(\"1996-12-31\"), \"days\")\n\n# Subset\nxts_Inteval <- xts_Rhur[ts_Inteval, ]\nhead(xts_Inteval, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           Bachum Villigst\n1996-01-01 13.459    11.03\n1996-01-02 12.331    10.03\n1996-01-03 11.112     9.12\n1996-01-04 11.272     8.11\n1996-01-05 11.412     8.71\n1996-01-06 11.526     8.29\n1996-01-07 12.589     9.45\n1996-01-08 12.508    10.09\n1996-01-09 12.336     9.42\n1996-01-10 12.510     8.47\n```\n\n\n:::\n:::\n\n\n\n\n\n# Rolling Windows\n\nMoving averages are a valuable tool for smoothing time series data and uncovering underlying trends or patterns. With rolling windows, you can calculate not only the mean value but also other statistics like the median and sum. To expand the range of functions available, you can utilize the `rollapply()`. This enables you to apply a wide variety of functions to your time series data within specified rolling windows.\n\n- `rollmean()`\n- `rollmedian()`\n- `rollsum()`\n- `rollmax()`\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxts_RollMean <- rollmean(xts_Inteval, 7)\nhead(xts_RollMean, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             Bachum Villigst\n1996-01-04 11.95729 9.248571\n1996-01-05 11.82143 9.114286\n1996-01-06 11.82214 9.027143\n1996-01-07 12.02186 8.934286\n1996-01-08 12.23314 9.242857\n1996-01-09 12.37214 9.238571\n1996-01-10 12.61357 9.541429\n1996-01-11 12.62643 9.535714\n1996-01-12 12.56257 9.357143\n1996-01-13 12.50186 9.242857\n```\n\n\n:::\n:::\n\n\n\n\n\n# Summary in Calendar Period\n\n\nDealing with irregularly spaced time series data can be challenging. One fundamental operation in time series analysis is applying a function by calendar period. This process helps in summarizing and analyzing time series data more effectively, even when the data points are irregularly spaced in time.\n\n- `apply.daily()`\n- `apply.weekly()`\n- `apply.monthly()`\n- `apply.quarterly()`\n- `apply.yearly()`\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxts_Month <- apply.monthly(xts_Inteval, mean)\nxts_Month\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n              Bachum  Villigst\n1996-01-31 12.478387  9.348065\n1996-02-29 15.794241 17.403448\n1996-03-31 14.244613 13.252903\n1996-04-30 10.217533  7.310667\n1996-05-31  9.331129  7.094839\n1996-06-30 10.589067  6.700667\n1996-07-31 11.607968  8.248710\n1996-08-31 12.897806  9.410968\n1996-09-30 14.516733 12.750000\n1996-10-31 18.214161 17.702903\n1996-11-30 30.673967 35.472667\n1996-12-31 35.720290 39.940645\n```\n\n\n:::\n:::\n",
    "supporting": [
      "timeserises_process_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}