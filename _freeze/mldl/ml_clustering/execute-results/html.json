{
  "hash": "14ecf9b0de4e2f8f652c8b8be498bc5a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Clustering\nexecute:\n  warning: false\n  error: false\nsidebar:\n  contents: auto\nnumber-sections: true\n---\n\n\n\n\n\n# Library and Data\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidymodels)\nlibrary(tidyverse)\ntheme_set(theme_bw())\nlibrary(tidyclust)\nlibrary(embed)\n# library(cluster)\nlibrary(dbscan)\nlibrary(ggdendro)\nlibrary(patchwork)\nlibrary(ggforce)\nlibrary(reshape2)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolor_RUB_blue <- \"#17365c\"\ncolor_RUB_green <- \"#8dae10\"\ncolor_TUD_pink <- \"#EC008D\"\ncolor_DRESDEN <- c(\"#03305D\", \"#28618C\", \"#539DC5\", \"#84D1EE\", \"#009BA4\", \"#13A983\", \"#93C356\", \"#BCCF02\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_Substance <- read.csv(\"../data_share/df_2010_bafg.csv\", row.names = 1)\n```\n:::\n\n\n\n\n# EDA\n\nWe have loaded the data into a DataFrame. First, let's have a look at the structure of the data.\n\nAs we can see, there might be datapoints/rows with some NaN values left. Since we only want to retain data with a valid date, we can drop all rows with date == NaN. Then, we inspect column the names and some of their contents.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Drop rows where \"date\" is NA\ndf_Substance <- df_Substance[!is.na(df_Substance$date), ]\n\n# Print all column names\nprint(paste(\"All columns:\", paste(names(df_Substance), collapse = \", \")))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"All columns: sampling_location, river, matrix, sampling_type_discharge, date, unit_discharge, less_than_discharge, discharge, substance, sampling_type_conc, unit_conc, less_than_conc, conc, sampling_type_ph, unit_ph, less_than_ph, ph, load, datetime, year, month, dayofyear, lon, lat\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Sampling locations (title case)\nunique(df_Substance$sampling_location)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"KAMPEN\"                \"BISCHOFSHEIM\"          \"KAHL AM MAIN\"         \n [4] \"KOBLENZ\"               \"PALZEM\"                \"MANNHEIM\"             \n [7] \"BAD HONNEF\"            \"BIMMEN\"                \"KARLSRUHE\"            \n[10] \"LAUTERBOURG-KARLSRUHE\" \"LOBITH\"                \"MAASSLUIS\"            \n[13] \"MAINZ\"                 \"OEHNINGEN\"             \"REKINGEN\"             \n[16] \"WEIL AM RHEIN\"         \"WORMS\"                 \"KANZEM\"               \n[19] \"SAARBRUECKEN\"          \"TREBUR-ASTHEIM\"       \n```\n\n\n:::\n\n```{.r .cell-code}\n# Rivers (title case)\nunique(df_Substance$river)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"IJSSEL\"      \"MAIN\"        \"MOSEL\"       \"NECKAR\"      \"RHEIN\"      \n[6] \"SAAR\"        \"SCHWARZBACH\"\n```\n\n\n:::\n:::\n\n\n\n\nThere are sampling locations as well as river names. The dataset's main river is the Rhine, but there are also tributaries to the Rhine included. Some locations might also have multiple rivers:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Rivers at the sampling location Koblenz\nunique(df_Substance$river[df_Substance$sampling_location == \"KOBLENZ\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"MOSEL\" \"RHEIN\"\n```\n\n\n:::\n:::\n\n\n\n\nThere are also two sampling locations that seem to be similar: Lauterbourg-Karlsruhe and Karlsruhe. We will check, if these are duplicates at a later point. For now we can make a mental note.\n\nThe three main data columns are 'discharge', 'conc', and 'ph'. 'discharge' and 'ph' should be self explanatory. 'conc' holds the concentration of the substance in the column 'substance'. Each of these has the corresponding data columns: unit_, less_than_ and sampling_type_ (which are less important for the pH value, but still included). unit_ and less_than_ denote the unit and give a hint to whether the measured value was below the level of detectability, respectively. less_than_ might be True or False; if it is False, the measured value could be quantified.\n\nLet's have a look at the units and substances.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Discharge units\nunique(df_Substance$unit_discharge)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"\"     \"m³/s\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Concentration units\nunique(df_Substance$unit_conc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"µg/l\" \"\"    \n```\n\n\n:::\n\n```{.r .cell-code}\n# Substances\nunique(df_Substance$substance)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"As\" \"Pb\" \"Cd\" \"Cr\" \"K\"  \"Ca\" \"Cu\" \"Mg\" \"Na\" \"Ni\" \"P\"  \"Hg\" \"Zn\" \"\"   \"AS\"\n[16] \"B\"  \"Fe\" \"Mn\"\n```\n\n\n:::\n:::\n\n\n\n\nFor the discharge the unit is m³/s, but there are some rows, where there is no discharge recorded, so there is also NaN for these rows.\nFor the concentration the unit is µg/L, but similar to discharge, there are some rows with NaN.\nIn the dataset, there seems to be a total of 17 substances and NaN for the same reason as above. However there is 'As' and 'AS', which both stand for arsenic. We need to fix this. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_Substance$substance[df_Substance$substance == \"AS\"] <- \"As\"\n\nunique(df_Substance$substance)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"As\" \"Pb\" \"Cd\" \"Cr\" \"K\"  \"Ca\" \"Cu\" \"Mg\" \"Na\" \"Ni\" \"P\"  \"Hg\" \"Zn\" \"\"   \"B\" \n[16] \"Fe\" \"Mn\"\n```\n\n\n:::\n:::\n\n\n\n\nLooks much better now: we have a total of 16 substances and NaN.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_substances <- df_Substance[!is.na(df_Substance$conc), ]\n\nggplot(df_substances, aes(x = conc)) +\n  geom_histogram(bins = 50, color = color_RUB_blue, fill = color_RUB_green) +\n  labs(\n    x = \"Concentration (µg/L)\",\n    y = \"Count\",\n    title = \"Histogram of substance concentrations\"\n  )\n```\n\n::: {.cell-output-display}\n![](ml_clustering_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\n\nIn the dataset there is a large quantity of concentrations below 0.1 µg/L. We still have the concentrations below detectability included. We do not know, what the exact values for the concentrations are in these cases, so we discard the respective rows.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_substances_quant <- df_substances[df_substances$less_than_conc == \"False\", ]\nggplot(df_substances_quant, aes(x = conc)) +\n  geom_histogram(bins = 50, color = color_RUB_blue, fill = color_RUB_green) +\n  labs(\n    x = \"Concentration (µg/L)\",\n    y = \"Count\",\n    title = \"Histogram of substance concentrations\"\n  )\n```\n\n::: {.cell-output-display}\n![](ml_clustering_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\n\nNow we fewer measurements and especially the concentrations below 0.1 µg/L have become fewer. There are still some possible outliers. Optional: We can use IQR to exclude these. Since every substance has its own concentration range, we have to calculate IQR for every substance independently.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall_substances <- unique(df_substances_quant$substance)\ndf_iqr <- do.call(rbind, lapply(all_substances, function(substance) {\n  df_sub <- df_substances_quant[df_substances_quant$substance == substance, ]\n  q1 <- quantile(df_sub$conc, 0.25, na.rm = TRUE)\n  q3 <- quantile(df_sub$conc, 0.75, na.rm = TRUE)\n  iqr_substance <- q3 - q1\n  lower <- q1 - 1.5 * iqr_substance\n  upper <- q3 + 1.5 * iqr_substance\n  df_sub[df_sub$conc >= lower & df_sub$conc <= upper, ]\n}))\n\n\nggplot(df_iqr, aes(x = conc)) +\n  geom_histogram(bins = 50, color = color_RUB_blue, fill = color_RUB_green) +\n  labs(\n    x = \"Concentration (µg/L)\",\n    y = \"Count\",\n    title = \"Histogram of substance concentrations\"\n  )\n```\n\n::: {.cell-output-display}\n![](ml_clustering_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\n\n\nOne clustering application one might come to try out is to identify substance groups from concentrations, pH values, and discharge. Let's first plot these values.\n\n\n\n\n::: {.cell fig-fullwidth='true'}\n\n```{.r .cell-code}\n# Create a color palette\ncolors <- scales::hue_pal()(length(all_substances))\nnames(colors) <- all_substances\n\n# Scatter plot: Discharge vs Concentration\ngp_Concen1 <- ggplot(df_iqr, aes(x = discharge, y = conc, color = substance)) +\n  geom_point(alpha = 0.7) +\n  scale_color_manual(values = colors) +\n  labs(x = \"Discharge (m³/s)\", y = \"Concentration (µg/L)\") +\n  theme(legend.position = \"right\")\n\n# Scatter plot: pH vs Concentration\ngp_Concen2 <- ggplot(df_iqr, aes(x = ph, y = conc, color = substance)) +\n  geom_point(alpha = 0.7) +\n  scale_color_manual(values = colors) +\n  labs(x = \"pH (-)\", y = NULL) +\n  theme(legend.position = \"none\")\n\n# Combine plots\ngp_Concen1 + gp_Concen2 + plot_layout(guides = \"collect\")\n```\n\n::: {.cell-output-display}\n![](ml_clustering_files/figure-html/unnamed-chunk-11-1.png){width=864}\n:::\n:::\n\n\n\n\nSince we already know the different substance groups, we can see, that they all share a similar space of concentration over discharge or pH. Here, trying to find the distinct substances from our numerical data would be a classification problem anyways, but the diagrams also show, that clustering would not be suitable since we see a lot of overlap.\n\nThere are still some unreasonable low pH values left that have to be removed. We still need to have a look at the possible duplicate data in Karlsruhe. \n\n\n\n\n::: {.cell fig-fullwidth='true'}\n\n```{.r .cell-code}\n# Filter data\ndf_filtered <- df_iqr[df_iqr$ph > 2, ]\ndf_k <- df_filtered[df_filtered$sampling_location == \"KARLSRUHE\", ]\ndf_k_l <- df_filtered[df_filtered$sampling_location == \"LAUTERBOURG-KARLSRUHE\", ]\n\n# Create as many colors as needed\ncolors <- scales::hue_pal()(length(all_substances))\nnames(colors) <- all_substances\n\n# Plot: Karlsruhe\ngp_Karl <- ggplot(df_k, aes(x = discharge, y = conc, color = substance)) +\n  geom_point(alpha = 0.7) +\n  scale_color_manual(values = colors) +\n  labs(title = \"Karlsruhe\", x = \"Discharge (m³/s)\", y = \"Concentration (µg/L)\") +\n  theme(legend.position = \"right\") +\n  ylim(-5000, 80000)\n\n# Plot: Lauterbourg-Karlsruhe\ngp_Laut <- ggplot(df_k_l, aes(x = discharge, y = conc, color = substance)) +\n  geom_point(alpha = 0.7) +\n  scale_color_manual(values = colors) +\n  labs(title = \"Lauterbourg-Karlsruhe\", x = \"Discharge (m³/s)\") +\n  theme(legend.position = \"none\",\n        axis.text.y = element_blank(),\n        axis.title.y = element_blank()) +\n  ylim(-5000, 80000)\n\n# Combine plots\ngp_Karl + gp_Laut + plot_layout(guides = \"collect\")\n```\n\n::: {.cell-output-display}\n![](ml_clustering_files/figure-html/unnamed-chunk-12-1.png){width=864}\n:::\n\n```{.r .cell-code}\n# Print unique rivers\nunique(df_k$river)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA      \"RHEIN\"\n```\n\n\n:::\n\n```{.r .cell-code}\nunique(df_k_l$river)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA      \"RHEIN\"\n```\n\n\n:::\n:::\n\n\n\n\nFrom a visual perspective, the Karlsruhe subset seems to be included in the Lauterbourg-Karlsruhe data. For the intents of this exercise, visual inspection is enough here, and we discard the Karlsruhe subset.\n\n\n## Final data\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_final <- df_filtered[df_filtered$sampling_location != \"KARLSRUHE\", ]\n```\n:::\n\n\n\n\n\n\n# Unsupervised Learning -- Source Allocation\n\nSubstances in the aquatic environment might have different emission sources and pathways. Some substances will have similar behaviour. To find and know such similarities greatly helps in modelling studies and regulatory policies. Since the groupings of similar substances are unknown to us, unsupervised learning can be applied. Several clustering techniques can aid us in finding groups. \nThis works by comparing concentration profiles at different sampling locations. \n\nIn the following use PCA and UMAP to reduce the dimensionality of the data. Then cluster the scores of the respective substances using different clustering techniques. How many clusters should you choose? How does the clustering compare to your subjective visual inspection? How should the input data be scaled? How is the final clustering affected?\n\nAt the end, create a consesus matrix and interpret the results.\n\n## Feature engineering\n\nFirst, the features have to be engineered. Each sampling location at each river is a feature for our substance observations. In this exercise we calculate the median of all concentration over the last ten year. NaN values are filled with 0.\n\n## Preprocessing\n\nHow should the features be scaled? Try out different techniques. How are they affecting the result?\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_PCA <- df_final\ndf_PCA <- df_PCA[df_PCA$year >= 2015, ]\n\n# Create \"site\" combining sampling_location and river\ndf_PCA$site <- paste(df_PCA$sampling_location, df_PCA$river, sep = \"_\")\n\n# Pivot to wide format with median concentrations\ndf_PCA_Summary <- df_PCA |>\n  group_by(site, substance) |>\n  summarize(conc_median = median(conc, na.rm = TRUE), .groups = \"drop\") |>\n  pivot_wider(names_from = substance, values_from = conc_median, values_fill = 0) |> \n  dplyr::select(-`NA`) |>\n  filter(site != \"NA_NA\")\n\n\nmat_PCA_Summary <- df_PCA_Summary[,-1]\ndf_Clust_Substance <- t(mat_PCA_Summary) |> as.data.frame()\ncolnames(df_Clust_Substance) <- df_PCA_Summary$site\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrcp_Clust2 <- recipe(~ ., data = df_Clust_Substance) |>\n  step_YeoJohnson(all_predictors()) |> # ?????\n  step_normalize(all_predictors())  # normalize all columns\n\n# Prep and bake\ndf_Clust_Normal <- prep(rcp_Clust2) |> bake(new_data = NULL)\nrownames(df_Clust_Normal) <- rownames(df_Clust_Substance)\n\n# Perform PCA\npca_Clust <- prcomp(df_Clust_Normal, scale. = FALSE)  # already normalized\n\n# Eigenvalues\neigen_Clust <- pca_Clust$sdev^2\n\n# Scree plot\nggplot() +\n  geom_point(aes(x = 1:length(eigen_Clust), y = eigen_Clust)) +\n  geom_hline(yintercept = 1, linetype = \"dashed\", color = color_TUD_pink) +\n  labs(x = \"PC\", y = \"Eigenvalue\")\n```\n\n::: {.cell-output-display}\n![](ml_clustering_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\n\n## Number of Principal Components\n\nNumber of PCA components: if we use standardized data, we can use the Kaiser Criterion. Otherwise we can also choose the number of component as such that the PCA explains 95% of the variance.\n\n\n\n\n::: {.cell fig-fullwidth='true'}\n\n```{.r .cell-code}\n# Recipe for PCA on clustering data\nrcp_Clust_PCA <- recipe(~ ., data = df_Clust_Substance) |>\n  step_YeoJohnson(all_predictors()) |>  # ?????\n  step_normalize(all_predictors()) |>  # normalize all numeric columns\n  step_pca(all_predictors(), num_comp = 3)  # keep first 4 PCs\n\n# Prep and bake\ndf_Clust_PCA <- prep(rcp_Clust_PCA) |> bake(new_data = NULL)\ndf_Clust_Plot_PCA <- df_Clust_PCA\ndf_Clust_Plot_PCA$substance <- rownames(df_Clust_Substance)\nggplot(df_Clust_Plot_PCA, aes(x = .panel_x, y = .panel_y)) +\n  geom_point(aes(shape = substance), color = color_RUB_blue) +\n  scale_shape_manual(values = 1:length(unique(df_Clust_Plot_PCA$substance))) +\n  geom_autodensity(alpha = 0.8, fill = color_RUB_green, color = color_RUB_blue) +\n  facet_matrix(vars(-substance), layer.diag = 2)\n```\n\n::: {.cell-output-display}\n![](ml_clustering_files/figure-html/unnamed-chunk-16-1.png){width=864}\n:::\n:::\n\n\n\n\n# Hierachical \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# HIERARCHICAL CLUSTERING ------------\n\nmdl_Hclust <- hier_clust(\n  num_clusters = 4,\n  linkage_method = \"complete\"  # or \"single\", \"average\", \"ward.D2\"\n) |>\n  set_engine(\"stats\")\n\n# Workflow\nwflow_Hclust <- workflow() |>\n  add_recipe(rcp_Clust_PCA) |>\n  add_model(mdl_Hclust)\n\n# Fit the model\nfit_Hclust <- fit(wflow_Hclust, data = df_Clust_Substance)\n\n# Extract cluster assignments\nclst_Hclust <- fit_Hclust |>\n  extract_cluster_assignment()\n```\n:::\n\n::: {.cell fig-fullwidth='true'}\n\n```{.r .cell-code}\nlabel_clst_Hclust <- clst_Hclust$.cluster\nnames(label_clst_Hclust) <- rownames(df_Clust_Substance)\nmat_Dist <- dist(df_Clust_PCA)\ndf_Hc <- hclust(mat_Dist, method = \"complete\")\n# Set labels (same order as df_Clust_Substance)\ndf_Hc$labels <- rownames(df_Clust_Substance)\n# Convert to dendro format\ndend_Data <- as.dendrogram(df_Hc) |> dendro_data()\ndf_clst_Match <- tibble(\n  label = dend_Data$labels$label,\n  cluster = label_clst_Hclust[dend_Data$labels$label]\n)\n\n# Join segment → label → cluster\ndf_Segment_Hclst <- dend_Data$segments %>%\n  left_join(dend_Data$labels %>% select(label, x), by = \"x\") %>%\n  left_join(df_clst_Match, by = \"label\")\n\n# Fill NA cluster values upward in tree\ndf_Segment_Hclst$cluster <- zoo::na.locf(df_Segment_Hclst$cluster, fromLast = TRUE)\n\nggplot() +\n  geom_segment(data = df_Segment_Hclst,\n               aes(x = x, y = y, xend = xend, yend = yend,\n                   color = factor(cluster)),\n               linewidth = 0.7) +\n  geom_text(data = dend_Data$labels,\n            aes(x = x, y = y, label = label),\n            hjust = 1, angle = 90, size = 3) +\n  labs(title = \"Dendrogram (Complete Linkage)\",\n       x = \"\", y = \"Height\", color = \"Cluster\") +\n  theme(axis.text.x = element_blank(),\n        axis.ticks.x = element_blank(),\n        panel.grid = element_blank())\n```\n\n::: {.cell-output-display}\n![](ml_clustering_files/figure-html/unnamed-chunk-18-1.png){width=864}\n:::\n:::\n\n::: {.cell fig-fullwidth='true'}\n\n```{.r .cell-code}\ndf_Hclust_Plot <- cbind(df_Clust_Plot_PCA, clst_Hclust)\n# Scatter plot: PC1 vs PC2\ngp_Hclust1 <- ggplot(df_Hclust_Plot, aes(x = PC2, y = PC1, color = .cluster, shape = substance)) +\n  geom_point(size = 2) +\n  scale_shape_manual(values = 1:length(unique(df_Clust_Plot_PCA$substance))) +\n  geom_mark_ellipse(aes(x = PC2, y = PC1, group = .cluster), alpha = 0.2, show.legend = FALSE) +\n  labs(x = \"PC2\", y = \"PC1\")\n\n# Scatter plot: PC1 vs PC3\ngp_Hclust2 <- ggplot(df_Hclust_Plot, aes(x = PC3, y = PC1, color = .cluster, shape = substance)) +\n  geom_point(size = 2) +\n  scale_shape_manual(values = 1:length(unique(df_Clust_Plot_PCA$substance))) +\n  geom_mark_ellipse(aes(x = PC3, y = PC1, group = .cluster), alpha = 0.2, show.legend = FALSE) +\n  labs(x = \"PC3\", y = \"PC1\")\ngp_Hclust1 + (gp_Hclust2 + theme(axis.text.y = element_blank(),\n                                 axis.title.y = element_blank())) + plot_layout(guides = \"collect\")\n```\n\n::: {.cell-output-display}\n![](ml_clustering_files/figure-html/unnamed-chunk-19-1.png){width=864}\n:::\n:::\n\n\n\n\n\n# K-Means\n\nTo find the appropriate number of clusters, we can use the elbow test. If the elbow test does not work as expected, i.e. it does not flat out, we can still use the silhouette method.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_Kmeans_Elbow <- tibble(k = 2:8, wss_value = NA)\ndf_Kmeans_Silhouette <- tibble(\n  k = 2:8, \n  avg_silhouette = NA\n)\n\nfor (i in 2:8) {\n  set.seed(123)\n  fit_Temp <- workflow() |>\n    add_recipe(rcp_Clust_PCA) |>\n    add_model(k_means(num_clusters = i) |> set_engine(\"stats\")) |>\n    fit(data = df_Clust_Substance)\n  \n  df_Kmeans_Elbow$wss_value[df_Kmeans_Elbow$k == i] <- fit_Temp |> \n    extract_fit_engine() |> \n    pluck(\"tot.withinss\")\n  \n\n  clusters <- fit_Temp |> extract_cluster_assignment()\n  # Prepare PCA data\n\n  # Calculate silhouette scores\n  sil <- cluster::silhouette(as.numeric(clusters$.cluster), dist(df_Clust_PCA))\n  \n  # Store average silhouette width\n  df_Kmeans_Silhouette$avg_silhouette[df_Kmeans_Silhouette$k == i] <- \n    mean(sil[, 3])\n  \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot elbow curve\nggplot(df_Kmeans_Elbow, aes(x = k, y = wss_value)) +\n  geom_line(color = color_RUB_blue) +\n  geom_point(color = color_RUB_green) +\n  labs(title = \"Elbow Method\", \n       x = \"Number of Clusters (k)\", \n       y = \"Inertia (Within-Cluster Sum of Squares)\")\n```\n\n::: {.cell-output-display}\n![](ml_clustering_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df_Kmeans_Silhouette, aes(x = k, y = avg_silhouette)) +\n  geom_line(color = color_RUB_blue) +\n  geom_point(color = color_RUB_green) +\n  labs(\n    title = \"Average Silhouette Score\",\n    x = \"Number of Clusters (k)\",\n    y = \"Average Silhouette Width\"\n  )\n```\n\n::: {.cell-output-display}\n![](ml_clustering_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Model specification\nmdl_Kmeans <- k_means(num_clusters = 4)\n\n# Workflow\nwflow_Kmeans <- workflow() |>\n  add_recipe(rcp_Clust_PCA) |>\n  add_model(mdl_Kmeans)\n\n# Fit the model\nfit_Kmeans <- fit(wflow_Kmeans, data = df_Clust_Substance)\nfit_Kmeans$fit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$actions\n$actions$model\n$spec\nK Means Cluster Specification (partition)\n\nMain Arguments:\n  num_clusters = 4\n\nComputational engine: stats \n\n\n$formula\nNULL\n\nattr(,\"class\")\n[1] \"action_model\" \"action_fit\"   \"action\"      \n\n\n$fit\ntidyclust cluster object\n\nK-means clustering with 4 clusters of sizes 8, 3, 4, 1\n\nCluster means:\n         PC1        PC2         PC3\n4  3.4205036  0.5357729 -0.06749066\n3  0.3120363 -2.2480213  0.18604062\n1 -6.3632349  0.4287831  0.01395718\n2 -2.8471982  0.7427479 -0.07402531\n\nClustering vector:\n [1] 1 2 3 1 1 2 3 3 2 3 4 1 1 1 1 1\n\nWithin cluster sum of squares by cluster:\n[1] 5.3145651 8.1079259 0.7094945 0.0000000\n (between_SS / total_SS =  95.2 %)\n\nAvailable components:\n\n[1] \"cluster\"      \"centers\"      \"totss\"        \"withinss\"     \"tot.withinss\"\n[6] \"betweenss\"    \"size\"         \"iter\"         \"ifault\"      \n\nattr(,\"class\")\n[1] \"stage_fit\" \"stage\"    \n```\n\n\n:::\n\n```{.r .cell-code}\n# Extract cluster assignments\nclst_Kmeans <- fit_Kmeans |>\n  extract_cluster_assignment()\nclst_Kmeans_Centroids <- fit_Kmeans |> extract_centroids()\n```\n:::\n\n::: {.cell fig-fullwidth='true'}\n\n```{.r .cell-code}\ndf_Kmeans_Plot <- cbind(df_Clust_Plot_PCA, clst_Kmeans)\n# Scatter plot: PC1 vs PC2\ngp_Kmeans1 <- ggplot(df_Kmeans_Plot, aes(x = PC2, y = PC1, color = .cluster, shape = substance)) +\n  geom_point(size = 2) +\n  scale_shape_manual(values = 1:length(unique(df_Clust_Plot_PCA$substance))) +\n  geom_point(data = clst_Kmeans_Centroids, \n             aes(x = PC2, y = PC1, color = .cluster), \n             shape = \"X\", size = 4) +\n  geom_mark_ellipse(aes(x = PC2, y = PC1, group = .cluster), alpha = 0.2, show.legend = FALSE) +\n  labs(x = \"PC2\", y = \"PC1\")\n\n# Scatter plot: PC1 vs PC3\ngp_Kmeans2 <- ggplot(df_Kmeans_Plot, aes(x = PC3, y = PC1, color = .cluster, shape = substance)) +\n  geom_point(size = 2) +\n  scale_shape_manual(values = 1:length(unique(df_Clust_Plot_PCA$substance))) +\n  geom_point(data = clst_Kmeans_Centroids, \n             aes(x = PC3, y = PC1, color = .cluster), \n             shape = \"X\", size = 4) +\n  geom_mark_ellipse(aes(x = PC3, y = PC1, group = .cluster), alpha = 0.2, show.legend = FALSE) +\n  labs(x = \"PC3\", y = \"PC1\")\ngp_Kmeans1 + (gp_Kmeans2 + theme(axis.text.y = element_blank(),\n                                 axis.title.y = element_blank())) + plot_layout(guides = \"collect\")\n```\n\n::: {.cell-output-display}\n![](ml_clustering_files/figure-html/unnamed-chunk-24-1.png){width=864}\n:::\n:::\n\n\n\n\n\n\n# DBSCAN\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# dbscan -----------\n\nfit_DBSCAN <- dbscan(df_Clust_PCA, eps = 2, minPts = 2)\nclst_DBSCAN <- paste0(\"Cluster_\", fit_DBSCAN$cluster)\nclst_DBSCAN[clst_DBSCAN == \"Cluster_0\"] <- NA\n```\n:::\n\n::: {.cell fig-fullwidth='true'}\n\n```{.r .cell-code}\ndf_DBSCAN_Plot <- cbind(df_Clust_Plot_PCA, .cluster = clst_DBSCAN)\n# Scatter plot: PC1 vs PC2\ngp_DBSCAN1 <- ggplot(df_DBSCAN_Plot, aes(x = PC2, y = PC1, color = .cluster, shape = substance)) +\n  geom_point(size = 2) +\n  scale_shape_manual(values = 1:length(unique(df_Clust_Plot_PCA$substance))) +\n  geom_mark_ellipse(aes(x = PC2, y = PC1, group = .cluster), alpha = 0.2, show.legend = FALSE) +\n  labs(x = \"PC2\", y = \"PC1\")\n\n# Scatter plot: PC1 vs PC3\ngp_DBSCAN2 <- ggplot(df_DBSCAN_Plot, aes(x = PC3, y = PC1, color = .cluster, shape = substance)) +\n  geom_point(size = 2) +\n  scale_shape_manual(values = 1:length(unique(df_Clust_Plot_PCA$substance))) +\n  geom_mark_ellipse(aes(x = PC3, y = PC1, group = .cluster), alpha = 0.2, show.legend = FALSE) +\n  labs(x = \"PC3\", y = \"PC1\")\ngp_DBSCAN1 + (gp_DBSCAN2 + theme(axis.text.y = element_blank(),\n                                 axis.title.y = element_blank())) + plot_layout(guides = \"collect\")\n```\n\n::: {.cell-output-display}\n![](ml_clustering_files/figure-html/unnamed-chunk-26-1.png){width=864}\n:::\n:::\n\n\n\n\n\n# UMAP\n\nInstead of PCA, one can also use UMAP for dimensionality reduction.\n\n\n\n\n\n::: {.cell fig-fullwidth='true'}\n\n```{.r .cell-code}\n# Recipe for UMAP on clustering data\nset.seed(42)\nrcp_Clust_UMAP <- recipe(~ ., data = df_Clust_Substance) |>\n  step_YeoJohnson(all_predictors()) |>  # ?????\n  step_normalize(all_predictors()) |>  # normalize all numeric columns\n  step_umap(all_predictors(), num_comp = 3)  # keep first 4 PCs\n\n# Prep and bake\ndf_Clust_UMAP <- prep(rcp_Clust_UMAP) |> bake(new_data = NULL)\ndf_Clust_Plot_UMAP <- df_Clust_UMAP\ndf_Clust_Plot_UMAP$substance <- rownames(df_Clust_Substance)\nggplot(df_Clust_Plot_UMAP, aes(x = .panel_x, y = .panel_y)) +\n  geom_point(aes(shape = substance), color = color_RUB_blue) +\n  scale_shape_manual(values = 1:length(unique(df_Clust_Plot_UMAP$substance))) +\n  geom_autodensity(alpha = 0.8, fill = color_RUB_green, color = color_RUB_blue) +\n  facet_matrix(vars(-substance), layer.diag = 2)\n```\n\n::: {.cell-output-display}\n![](ml_clustering_files/figure-html/unnamed-chunk-27-1.png){width=864}\n:::\n:::\n\n\n\n\n\n\n## Hierachical \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# HIERARCHICAL CLUSTERING ------------\n\nmdl_Hclust <- hier_clust(\n  num_clusters = 4,\n  linkage_method = \"complete\"  # or \"single\", \"average\", \"ward.D2\"\n) |>\n  set_engine(\"stats\")\n\n# Workflow\nwflow_Hclust_UMAP <- workflow() |>\n  add_recipe(rcp_Clust_UMAP) |>\n  add_model(mdl_Hclust)\n\n# Fit the model\nfit_Hclust_UMAP <- fit(wflow_Hclust_UMAP, data = df_Clust_Substance)\n\n# Extract cluster assignments\nclst_Hclust_UMAP <- fit_Hclust_UMAP |>\n  extract_cluster_assignment()\n```\n:::\n\n::: {.cell fig-fullwidth='true'}\n\n```{.r .cell-code}\nlabel_clst_Hclust_UMAP <- clst_Hclust_UMAP$.cluster\nnames(label_clst_Hclust_UMAP) <- rownames(df_Clust_Substance)\nmat_Dist_UMAP <- dist(df_Clust_UMAP)\ndf_Hc_UMAP <- hclust(mat_Dist_UMAP, method = \"complete\")\n# Set labels (same order as df_Clust_Substance)\ndf_Hc_UMAP$labels <- rownames(df_Clust_Substance)\n# Convert to dendro format\ndend_Data_UMAP <- as.dendrogram(df_Hc_UMAP) |> dendro_data()\ndf_clst_Match_UMAP <- tibble(\n  label = dend_Data_UMAP$labels$label,\n  cluster = label_clst_Hclust_UMAP[dend_Data_UMAP$labels$label]\n)\n\n# Join segment → label → cluster\ndf_Segment_Hclst_UMAP <- dend_Data_UMAP$segments %>%\n  left_join(dend_Data_UMAP$labels %>% dplyr::select(label, x), by = \"x\") %>%\n  left_join(df_clst_Match_UMAP, by = \"label\")\n\n# Fill NA cluster values upward in tree\ndf_Segment_Hclst_UMAP$cluster <- zoo::na.locf(df_Segment_Hclst_UMAP$cluster, fromLast = TRUE)\n\nggplot() +\n  geom_segment(data = df_Segment_Hclst_UMAP,\n               aes(x = x, y = y, xend = xend, yend = yend,\n                   color = factor(cluster)),\n               linewidth = 0.7) +\n  geom_text(data = dend_Data_UMAP$labels,\n            aes(x = x, y = y, label = label),\n            hjust = 1, angle = 90, size = 3) +\n  labs(title = \"Dendrogram (Complete Linkage)\",\n       x = \"\", y = \"Height\", color = \"Cluster\") +\n  theme(axis.text.x = element_blank(),\n        axis.ticks.x = element_blank(),\n        panel.grid = element_blank())\n```\n\n::: {.cell-output-display}\n![](ml_clustering_files/figure-html/unnamed-chunk-29-1.png){width=864}\n:::\n:::\n\n::: {.cell fig-fullwidth='true'}\n\n```{.r .cell-code}\ndf_Hclust_Plot_UMAP <- cbind(df_Clust_Plot_UMAP, clst_Hclust_UMAP)\n# Scatter plot: UMAP1 vs UMAP2\ngp_Hclust1_UMAP <- ggplot(df_Hclust_Plot_UMAP, aes(x = UMAP2, y = UMAP1, color = .cluster, shape = substance)) +\n  geom_point(size = 2) +\n  scale_shape_manual(values = 1:length(unique(df_Clust_Plot_UMAP$substance))) +\n  geom_mark_ellipse(aes(x = UMAP2, y = UMAP1, group = .cluster), alpha = 0.2, show.legend = FALSE) +\n  labs(x = \"UMAP2\", y = \"UMAP1\")\n\n# Scatter plot: UMAP1 vs UMAP3\ngp_Hclust2_UMAP <- ggplot(df_Hclust_Plot_UMAP, aes(x = UMAP3, y = UMAP1, color = .cluster, shape = substance)) +\n  geom_point(size = 2) +\n  scale_shape_manual(values = 1:length(unique(df_Clust_Plot_UMAP$substance))) +\n  geom_mark_ellipse(aes(x = UMAP3, y = UMAP1, group = .cluster), alpha = 0.2, show.legend = FALSE) +\n  labs(x = \"UMAP3\", y = \"UMAP1\")\ngp_Hclust1_UMAP + (gp_Hclust2_UMAP + theme(axis.text.y = element_blank(),\n                                 axis.title.y = element_blank())) + plot_layout(guides = \"collect\")\n```\n\n::: {.cell-output-display}\n![](ml_clustering_files/figure-html/unnamed-chunk-30-1.png){width=864}\n:::\n:::\n\n\n\n\n\n## K-Means\n\n\n### k test\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_Kmeans_Elbow_UMAP <- tibble(k = 2:8, wss_value = NA)\ndf_Kmeans_Silhouette_UMAP <- tibble(\n  k = 2:8, \n  avg_silhouette = NA\n)\n\nfor (i in 2:8) {\n  set.seed(666)\n  fit_Temp <- workflow() |>\n    add_recipe(rcp_Clust_UMAP) |>\n    add_model(k_means(num_clusters = i) |> set_engine(\"stats\")) |>\n    fit(data = df_Clust_Substance)\n  \n  df_Kmeans_Elbow_UMAP$wss_value[df_Kmeans_Elbow$k == i] <- fit_Temp |> \n    extract_fit_engine() |> \n    pluck(\"tot.withinss\")\n  \n\n  clusters <- fit_Temp |> extract_cluster_assignment()\n  # Prepare UMAPA data\n  \n  # Calculate silhouette scores\n  sil <- cluster::silhouette(as.numeric(clusters$.cluster), dist(df_Clust_UMAP))\n  \n  # Store average silhouette width\n  df_Kmeans_Silhouette_UMAP$avg_silhouette[df_Kmeans_Silhouette$k == i] <- \n    mean(sil[, 3])\n  \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot elbow curve\nggplot(df_Kmeans_Elbow_UMAP, aes(x = k, y = wss_value)) +\n  geom_line(color = color_RUB_blue) +\n  geom_point(color = color_RUB_green) +\n  labs(title = \"Elbow Method\", \n       x = \"Number of Clusters (k)\", \n       y = \"Inertia (Within-Cluster Sum of Squares)\")\n```\n\n::: {.cell-output-display}\n![](ml_clustering_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df_Kmeans_Silhouette_UMAP, aes(x = k, y = avg_silhouette)) +\n  geom_line(color = color_RUB_blue) +\n  geom_point(color = color_RUB_green) +\n  labs(\n    title = \"Average Silhouette Score\",\n    x = \"Number of Clusters (k)\",\n    y = \"Average Silhouette Width\"\n  )\n```\n\n::: {.cell-output-display}\n![](ml_clustering_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Model specification\nmdl_Kmeans <- k_means(num_clusters = 4)\n\n# Workflow\nwflow_Kmeans <- workflow() |>\n  add_recipe(rcp_Clust_UMAP) |>\n  add_model(mdl_Kmeans)\n\n# Fit the model\nfit_Kmeans_UMAP <- fit(wflow_Kmeans, data = df_Clust_Substance)\nfit_Kmeans_UMAP$fit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$actions\n$actions$model\n$spec\nK Means Cluster Specification (partition)\n\nMain Arguments:\n  num_clusters = 4\n\nComputational engine: stats \n\n\n$formula\nNULL\n\nattr(,\"class\")\n[1] \"action_model\" \"action_fit\"   \"action\"      \n\n\n$fit\ntidyclust cluster object\n\nK-means clustering with 4 clusters of sizes 4, 3, 5, 4\n\nCluster means:\n      UMAP1      UMAP2      UMAP3\n2 -1.485931 -0.4565657  0.6184530\n1  0.107790  0.1963375  0.3870043\n4  1.694379  1.1024476 -0.2248595\n3 -1.233836 -1.4374852 -0.6717862\n\nClustering vector:\n [1] 1 2 3 4 1 2 3 3 2 3 3 1 1 4 4 4\n\nWithin cluster sum of squares by cluster:\n[1] 2.236076 1.403089 3.421381 1.043195\n (between_SS / total_SS =  85.6 %)\n\nAvailable components:\n\n[1] \"cluster\"      \"centers\"      \"totss\"        \"withinss\"     \"tot.withinss\"\n[6] \"betweenss\"    \"size\"         \"iter\"         \"ifault\"      \n\nattr(,\"class\")\n[1] \"stage_fit\" \"stage\"    \n```\n\n\n:::\n\n```{.r .cell-code}\n# Extract cluster assignments\nclst_Kmeans_UMAP <- fit_Kmeans_UMAP |>\n  extract_cluster_assignment()\nclst_Kmeans_Centroids_UMAP <- fit_Kmeans_UMAP |> extract_centroids()\n```\n:::\n\n::: {.cell fig-fullwidth='true'}\n\n```{.r .cell-code}\ndf_Kmeans_Plot_UMAP <- cbind(df_Clust_Plot_UMAP, clst_Kmeans_UMAP)\n# Scatter plot: UMAP1 vs UMAP2\ngp_Kmeans1_UMAP <- ggplot(df_Kmeans_Plot_UMAP, aes(x = UMAP2, y = UMAP1, color = .cluster, shape = substance)) +\n  geom_point(size = 2) +\n  scale_shape_manual(values = 1:length(unique(df_Clust_Plot_UMAP$substance))) +\n  geom_point(data = clst_Kmeans_Centroids_UMAP, \n             aes(x = UMAP2, y = UMAP1, color = .cluster), \n             shape = \"X\", size = 4) +\n  geom_mark_ellipse(aes(x = UMAP2, y = UMAP1, group = .cluster), alpha = 0.2, show.legend = FALSE) +\n  labs(x = \"UMAP2\", y = \"UMAP1\")\n\n# Scatter plot: UMAP1 vs UMAP3\ngp_Kmeans2_UMAP <- ggplot(df_Kmeans_Plot_UMAP, aes(x = UMAP3, y = UMAP1, color = .cluster, shape = substance)) +\n  geom_point(size = 2) +\n  scale_shape_manual(values = 1:length(unique(df_Clust_Plot_UMAP$substance))) +\n  geom_point(data = clst_Kmeans_Centroids_UMAP, \n             aes(x = UMAP3, y = UMAP1, color = .cluster), \n             shape = \"X\", size = 4) +\n  geom_mark_ellipse(aes(x = UMAP3, y = UMAP1, group = .cluster), alpha = 0.2, show.legend = FALSE) +\n  labs(x = \"UMAP3\", y = \"UMAP1\")\ngp_Kmeans1_UMAP + (gp_Kmeans2_UMAP + theme(axis.text.y = element_blank(),\n                                 axis.title.y = element_blank())) + plot_layout(guides = \"collect\")\n```\n\n::: {.cell-output-display}\n![](ml_clustering_files/figure-html/unnamed-chunk-35-1.png){width=864}\n:::\n:::\n\n\n\n\n\n\n## DBSCAN\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# dbscan -----------\nfit_DBSCAN_UMAP <- dbscan(df_Clust_UMAP, eps = 1, minPts = 2)\nclst_DBSCAN_UMAP <- paste0(\"Cluster_\", fit_DBSCAN_UMAP$cluster)\nclst_DBSCAN_UMAP[clst_DBSCAN_UMAP == \"Cluster_0\"] <- NA\n```\n:::\n\n::: {.cell fig-fullwidth='true'}\n\n```{.r .cell-code}\ndf_DBSCAN_Plot_UMAP <- cbind(df_Clust_Plot_UMAP, .cluster = clst_DBSCAN_UMAP)\n# Scatter plot: UMAP1 vs UMAP2\ngp_DBSCAN1_UMAP <- ggplot(df_DBSCAN_Plot_UMAP, aes(x = UMAP2, y = UMAP1, color = .cluster, shape = substance)) +\n  geom_point(size = 2) +\n  scale_shape_manual(values = 1:length(unique(df_Clust_Plot_UMAP$substance))) +\n  geom_mark_ellipse(aes(x = UMAP2, y = UMAP1, group = .cluster), alpha = 0.2, show.legend = FALSE) +\n  labs(x = \"UMAP2\", y = \"UMAP1\")\n\n# Scatter plot: UMAP1 vs UMAP3\ngp_DBSCAN2_UMAP <- ggplot(df_DBSCAN_Plot_UMAP, aes(x = UMAP3, y = UMAP1, color = .cluster, shape = substance)) +\n  geom_point(size = 2) +\n  scale_shape_manual(values = 1:length(unique(df_Clust_Plot_UMAP$substance))) +\n  geom_mark_ellipse(aes(x = UMAP3, y = UMAP1, group = .cluster), alpha = 0.2, show.legend = FALSE) +\n  labs(x = \"UMAP3\", y = \"UMAP1\")\ngp_DBSCAN1_UMAP + (gp_DBSCAN2_UMAP + theme(axis.text.y = element_blank(),\n                                 axis.title.y = element_blank())) + plot_layout(guides = \"collect\")\n```\n\n::: {.cell-output-display}\n![](ml_clustering_files/figure-html/unnamed-chunk-37-1.png){width=864}\n:::\n:::\n\n\n\n\n\n\n# Consensus Matrix -- Co-clustering of substances\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat_Clust <- as.matrix(df_Clust_Normal)\nint_K <- 4\nn_Obsevation <- nrow(mat_Clust)\nmat_Consensus <- matrix(0, n_Obsevation, n_Obsevation)\nn_Run <- 100\nfor (i_Run in 1:n_Run) {\n  # you can choose any clustering algorithm (kmeans, pam, hclust)\n  fit <- kmeans(mat_Clust, centers = int_K)\n  clst_Km <- fit$cluster\n  # update mat_Consensus matrix\n  for (i in 1:n_Obsevation) {\n    for (j in 1:n_Obsevation) {\n      if (clst_Km[i] == clst_Km[j]) mat_Consensus[i, j] <- mat_Consensus[i, j] + 1\n    }\n  }\n}\n\n# normalize to 0–1\nmat_Consensus <- mat_Consensus / n_Run\nrownames(mat_Consensus) <- rownames(df_Clust_Normal)\ncolnames(mat_Consensus) <- rownames(df_Clust_Normal)\n# melt matrix\ndf_Consensus_Plot <- melt(mat_Consensus)\ncolnames(df_Consensus_Plot) <- c(\"Substance1\", \"Substance2\", \"Prob\")\n\n# optional: order substances by hierarchical clustering\nhc_Con <- hclust(dist(mat_Consensus))\nidx_Order <- hc_Con$labels[hc_Con$order]\ndf_Consensus_Plot$Substance1 <- factor(df_Consensus_Plot$Substance1, levels = idx_Order)\ndf_Consensus_Plot$Substance2 <- factor(df_Consensus_Plot$Substance2, levels = idx_Order)\n\n# heatmap\nggplot(df_Consensus_Plot, aes(Substance1, Substance2, fill = Prob)) +\n  geom_tile(color = \"grey96\") +\n  scale_fill_gradientn(\"Co-clustering\\nProbability\", colors = color_DRESDEN[-c(1:3)]) +\n  coord_fixed(ratio = 1, expand = FALSE) +\n  theme(axis.title.x = element_blank(),\n        axis.title.y = element_blank(),\n        axis.text.x = element_text(angle = 90, hjust = 1))\n```\n\n::: {.cell-output-display}\n![](ml_clustering_files/figure-html/unnamed-chunk-38-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "ml_clustering_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}